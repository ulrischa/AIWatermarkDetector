<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Watermark & Stego Scanner (Text + Code) — Low False Positives</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111a33;
      --text: #e8ecff;
      --muted: #aab3d6;
      --border: rgba(255,255,255,.10);
      --ok: #39d98a;
      --warn: #ffcf5c;
      --bad: #ff5c7a;
      --chip: rgba(255,255,255,.08);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 20% 0%, #182654 0%, var(--bg) 55%);
      color: var(--text);
    }
    .wrap { max-width: 1220px; margin: 0 auto; padding: 24px; }
    h1 { font-size: 22px; margin: 0 0 8px; letter-spacing: .2px; }
    a {color: var(--text); font-weight: bold;}
    .sub { color: var(--muted); margin: 0 0 18px; line-height: 1.45; }

    .grid { display: grid; grid-template-columns: 1.25fr .75fr; gap: 16px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h2 { font-size: 14px; margin: 0 0 10px; color: var(--muted); font-weight: 650; text-transform: uppercase; letter-spacing: .9px; }

    textarea {
      width: 100%;
      min-height: 280px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid var(--border);
      outline: none;
      padding: 12px 12px;
      background: rgba(0,0,0,.22);
      color: var(--text);
      line-height: 1.45;
      font-size: 14px;
    }
    textarea:focus { border-color: rgba(255,255,255,.22); box-shadow: 0 0 0 4px rgba(120,160,255,.12); }

    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .spacer { height: 12px; }

    button {
      border: 1px solid var(--border);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .2px;
    }
    button:hover { background: rgba(255,255,255,.12); }
    button:disabled { cursor: not-allowed; opacity: .55; }
    button.primary {
      background: linear-gradient(180deg, rgba(120,160,255,.30), rgba(120,160,255,.14));
      border-color: rgba(120,160,255,.35);
    }
    button.danger {
      background: linear-gradient(180deg, rgba(255,92,122,.28), rgba(255,92,122,.12));
      border-color: rgba(255,92,122,.35);
    }

    .chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip {
      background: var(--chip);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      display: inline-flex;
      gap: 8px;
      align-items: center;
      user-select: none;
    }
    .chip input { accent-color: #86a6ff; }

    .note { color: var(--muted); font-size: 12.5px; line-height: 1.45; margin-top: 10px; }

    .results { display: grid; gap: 12px; }
    .res { border: 1px solid var(--border); border-radius: 14px; background: rgba(0,0,0,.16); padding: 12px; }
    .resHead { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .resTitle { font-weight: 750; }
    .badge {
      font-size: 12px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      white-space: nowrap;
    }
    .badge.ok { color: var(--ok); border-color: rgba(57,217,138,.35); background: rgba(57,217,138,.10); }
    .badge.warn { color: var(--warn); border-color: rgba(255,207,92,.35); background: rgba(255,207,92,.10); }
    .badge.bad { color: var(--bad); border-color: rgba(255,92,122,.35); background: rgba(255,92,122,.10); }

    .resBody { margin-top: 10px; color: var(--muted); font-size: 13px; line-height: 1.5; }
    .mono { font-family: var(--mono); font-size: 12.5px; color: #d8defa; }
    .kvs { display: grid; grid-template-columns: 170px 1fr; gap: 6px 10px; }
    .k { color: var(--muted); }
    .v { color: var(--text); }
    .list { margin: 8px 0 0; padding-left: 18px; }
    .list li { margin: 3px 0; }
    .hr { height: 1px; background: var(--border); margin: 12px 0; }
    .small { font-size: 12px; color: var(--muted); }
    .right { margin-left: auto; }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: rgba(255,255,255,.35); }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.bad { background: var(--bad); }

    .twoCols { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 980px) { .twoCols { grid-template-columns: 1fr; } }

    .errorBox {
      border: 1px solid rgba(255,92,122,.35);
      background: rgba(255,92,122,.10);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.45;
    }
  </style>
</head>

<body>
<div class="wrap">
  <h1>AI Watermark & Stego Scanner (Text + Code)</h1>
  <p class="sub">
    Low-false-positive detection for verifiable patterns: Unicode invisibles/Bidi, confusables, normalization tricks,
    whitespace channels, encoded payloads, URL tracking tokens, acrostics, and repetition/uniformity heuristics.
    Optional PHP API improves Unicode/confusable checks (ICU).
    <br/>
    <a href="https://github.com/ulrischa/AIWatermarkDetector">More informationen in the github repo</a>
  </p>

  <div class="grid">
    <div class="card">
      <h2>Input</h2>
      <textarea id="input" spellcheck="false" placeholder="Paste text or code here, or load a test case …"></textarea>

      <div class="spacer"></div>

      <div class="row">
        <button class="primary" id="run" disabled>Run analysis</button>
        <button id="runAll">Enable all checks</button>
        <button id="clearSel">Clear selection</button>
        <button class="danger right" id="clearText">Clear text</button>
      </div>

      <div class="spacer"></div>

      <div class="twoCols">
        <div class="row">
          <span class="status" title="Server-side analysis is optional. If not reachable, client checks still work.">
            <span id="apiDot" class="dot warn"></span>
            <span id="apiText">API: not checked</span>
          </span>

          <label class="status" style="cursor:pointer;">
            <input id="useApi" type="checkbox" checked style="accent-color:#86a6ff;" />
            Use PHP API (optional)
          </label>
        </div>

        <div class="row">
          <label class="status" style="cursor:pointer;" title="Masks URLs for payload scans. Greatly reduces false positives.">
            <input id="maskUrls" type="checkbox" checked style="accent-color:#86a6ff;" />
            Mask URLs for payload checks
          </label>

          <label class="status" style="cursor:pointer;" title="Strict Base64: only counts if decoded bytes are readable UTF-8 or match known magic bytes.">
            <input id="strictBase64" type="checkbox" checked style="accent-color:#86a6ff;" />
            Strict Base64 mode
          </label>

          <label class="status" style="cursor:pointer;" title="Analyzes URL query params and classifies tracking-like tokens (e.g., srsltid, utm_*, gclid).">
            <input id="analyzeUrls" type="checkbox" checked style="accent-color:#86a6ff;" />
            Analyze URLs for tracking tokens
          </label>
        </div>
      </div>

      <div class="spacer"></div>

      <div class="chips" id="methodChips"></div>

      <div class="note">
        This scanner focuses on output patterns. Statistical “greenlist” watermarks typically require secret keys or model-side telemetry
        and cannot be reliably detected from text alone.
      </div>

      <div class="hr"></div>

      <h2>Test cases</h2>
      <div class="row" id="testButtons"></div>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div id="errorArea"></div>
      <div class="results" id="results"></div>

      <div class="hr"></div>

      <div class="kvs small">
        <div class="k">Last run</div><div class="v" id="lastRun">–</div>
        <div class="k">Input type</div><div class="v" id="inputType">–</div>
        <div class="k">Tokens (heuristic)</div><div class="v" id="tokenInfo">–</div>
        <div class="k">API used</div><div class="v" id="apiUsed">–</div>
      </div>
    </div>
  </div>
</div>

<script>
  const API_ENDPOINT = "./api/analyze.php";
  const API_TIMEOUT_MS = 1200;

  const METHODS = [
    { id: "unicode_specials", name: "Unicode invisibles / format / control chars" },
    { id: "unicode_bidi",     name: "Bidi / direction controls (Trojan Source)" },
    { id: "unicode_norm",     name: "Unicode normalization tricks (NFKC diff)" },
    { id: "unicode_homoglyph",name: "Homoglyphs / mixed scripts (confusables)" },
    { id: "stego_whitespace", name: "Whitespace channel signals (trailing / mixed / weird spaces)" },
    { id: "payload_base64",   name: "Base64 / Base64URL payloads (strict by default)" },
    { id: "payload_hex",      name: "Hex / escapes payloads (0x…, \\\\x.., \\\\u....)" },
    { id: "payload_urlenc",   name: "Percent-encoding payloads (%xx) (URLs masked by default)" },
    { id: "payload_entropy",  name: "High-entropy runs (encoded/compressed blobs) (URLs masked)" },
    { id: "url_tracking",     name: "URL tracking-like tokens (srsltid, utm_*, gclid, …)" },
    { id: "structure_acrostic", name: "Acrostics (sentences/lines/comments)" },
    { id: "style_repetition",   name: "Repetition / uniformity heuristics" },
    { id: "explicit_markers",   name: "Explicit AI/tool markers (URLs masked by default)" },
    { id: "code_identifier",    name: "Code identifier anomalies (mixed scripts/confusables)" }
  ];

  const REAL_WORLD_TEXT_WITH_TRACKING = `Links with tracking-like params:
[2]: https://www.wiwacam.com/product/wiwacam-mw5-4k-mini-spy-camera-hidden-camera-wifi-app-micro-sd-card-recording-night-vision/?srsltid=AfmBOor-JJ9x8cJDg85U0MbQkAxCB908ui9An8EOX04z8IWnzqm6_XuM&utm_source=chatgpt.com
[4]: https://www.wiwacam.com/privacypolicy/?srsltid=AfmBOop6qaBZc4DhuuYEOZHqZygm_vSQew-HAUMzfZUy7WB4TmfjMCnl&utm_source=chatgpt.com
`;

  const TESTS = [
    {
      id: "t_unicode_invisible",
      label: "Test: Invisible Unicode",
      text:
        "This has an invisible marker: Test\u200Bcase (ZWSP U+200B).\n" +
        "Also a no-break space: Word\u00A0Word.\n" +
        "And a WORD JOINER: A\u2060B."
    },
    {
      id: "t_unicode_bidi",
      label: "Test: Bidi Controls",
      text:
        "Bidi example: ABC \u202E123\u202C DEF (RLO … PDF).\n" +
        "Also isolate: X\u2067Y\u2069Z (RLI … PDI)."
    },
    {
      id: "t_unicode_homoglyph",
      label: "Test: Homoglyphs",
      text:
        "This is a Te\u0441t. (Cyrillic “с” U+0441)\n" +
        "G\u043E\u043Egle (Cyrillic “o” U+043E)."
    },
    {
      id: "t_unicode_norm",
      label: "Test: Normalization",
      text:
        "Compatibility char: \uFB01 (ligature fi) may normalize to 'fi'.\n" +
        "Full-width: \uFF21\uFF22\uFF23."
    },
    {
      id: "t_payload_base64_real",
      label: "Test: Base64 (real)",
      text:
        "Here is real Base64: SGVsbG8sIFVsaSE=\n" +
        "And a longer JSON-like base64:\n" +
        "eyJ0eXBlIjoidGVzdCIsIm9rIjp0cnVlfQ=="
    },
    {
      id: "t_payload_base64_noise",
      label: "Test: Base64 (noise words)",
      text:
        "These should NOT count as Base64 payloads in strict mode:\n" +
        "WPA2/WPA3-WLAN Broadcast/Multicast Metadaten/Netzwerkinfos confidence_reasoning"
    },
    {
      id: "t_ws_stego",
      label: "Test: Whitespace channel",
      text:
        "Line with trailing spaces.    \n" +
        "Line with trailing tabs.\t\t\n" +
        "Mixed indentation:\n" +
        "\tfunction test() {\n" +
        "    \treturn 1;\n" +
        "}\n"
    },
    {
      id: "t_tracking",
      label: "Test: URL tracking tokens",
      text: REAL_WORLD_TEXT_WITH_TRACKING
    }
  ];

  const elInput = document.getElementById("input");
  const elRun = document.getElementById("run");
  const elResults = document.getElementById("results");
  const elErrorArea = document.getElementById("errorArea");

  const elMethodChips = document.getElementById("methodChips");
  const elTestButtons = document.getElementById("testButtons");

  const elLastRun = document.getElementById("lastRun");
  const elTokenInfo = document.getElementById("tokenInfo");
  const elInputType = document.getElementById("inputType");
  const elApiUsed = document.getElementById("apiUsed");

  const elApiDot = document.getElementById("apiDot");
  const elApiText = document.getElementById("apiText");

  const elUseApi = document.getElementById("useApi");
  const elMaskUrls = document.getElementById("maskUrls");
  const elStrictBase64 = document.getElementById("strictBase64");
  const elAnalyzeUrls = document.getElementById("analyzeUrls");

  const state = {
    selected: new Set(METHODS.map(m => m.id)),
    apiReachable: false
  };

  function now_local_string() {
    const d = new Date();
    return d.toLocaleString("en-GB", { hour12: false });
  }

  function escape_html(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function as_mono(s) { return `<span class="mono">${escape_html(s)}</span>`; }

  function safe_slice_context(text, start, span = 24) {
    const s = Math.max(0, start - span);
    const e = Math.min(text.length, start + span);
    const prefix = (s > 0) ? "…" : "";
    const suffix = (e < text.length) ? "…" : "";
    return prefix + text.slice(s, e) + suffix;
  }

  function supports_unicode_property_escapes() {
    try { new RegExp("\\p{L}+", "u"); return true; } catch (_) { return false; }
  }

  function to_hex_u(codePoint) {
    return "U+" + codePoint.toString(16).toUpperCase().padStart(4, "0");
  }

  function clear_error() { elErrorArea.innerHTML = ""; }
  function show_error(message) {
    elErrorArea.innerHTML = `<div class="errorBox"><b>Error:</b> ${escape_html(message)}</div>`;
  }

  function has_text() { return (elInput.value || "").trim().length > 0; }
  function update_run_button_state() { elRun.disabled = !has_text(); }

  function classify_input(text) {
    const codeSignals = [
      /[{}`;]/, /=>/, /function\s+\w*\s*\(/, /class\s+\w+/, /#include\s*</,
      /\b(const|let|var|def|public|private|return|import|from|namespace)\b/,
      /^\s*(\/\/|\/\*|\*|\#)\s/m
    ];
    let score = 0;
    for (const re of codeSignals) if (re.test(text)) score++;
    if (score >= 2) return "code";
    if (score === 1 && /[\n\r]/.test(text) && text.split(/\r?\n/).length > 3) return "code-ish";
    return "text";
  }

  function tokenize(text) {
    const propEsc = supports_unicode_property_escapes();
    const re = propEsc ? /[\p{L}\p{N}_'-]+/gu : /[A-Za-z0-9_'-]+/g;
    const tokens = [];
    for (const m of text.matchAll(re)) tokens.push(m[0]);
    return tokens;
  }

  const URL_RE = /https?:\/\/[^\s<>()"'\]]+/g;

  function extract_urls(text) {
    const urls = [];
    for (const m of text.matchAll(URL_RE)) {
      urls.push({ url: m[0], index: m.index ?? 0 });
    }
    return urls;
  }

  function mask_urls(text, urls) {
    if (!urls.length) return text;
    let out = text;
    for (let i = urls.length - 1; i >= 0; i--) {
      const { url, index } = urls[i];
      out = out.slice(0, index) + " ".repeat(url.length) + out.slice(index + url.length);
    }
    return out;
  }

  const INVISIBLE_CANDIDATES = new Map([
    [0x200B, "ZERO WIDTH SPACE"],
    [0x200C, "ZERO WIDTH NON-JOINER"],
    [0x200D, "ZERO WIDTH JOINER"],
    [0x2060, "WORD JOINER"],
    [0xFEFF, "ZERO WIDTH NO-BREAK SPACE (BOM)"],
    [0x00A0, "NO-BREAK SPACE"],
    [0x202F, "NARROW NO-BREAK SPACE"],
    [0x2007, "FIGURE SPACE"],
    [0x2009, "THIN SPACE"],
    [0x200A, "HAIR SPACE"],
    [0x3000, "IDEOGRAPHIC SPACE"]
  ]);

  const BIDI_CONTROLS = new Map([
    [0x202A, "LRE"], [0x202B, "RLE"], [0x202C, "PDF"], [0x202D, "LRO"], [0x202E, "RLO"],
    [0x2066, "LRI"], [0x2067, "RLI"], [0x2068, "FSI"], [0x2069, "PDI"],
    [0x200E, "LRM"], [0x200F, "RLM"]
  ]);

  function detect_unicode_specials(text) {
    const findings = [];
    let i = 0;
    for (const ch of text) {
      const cp = ch.codePointAt(0);
      const is_ascii_ctrl = (cp < 32 && cp !== 9 && cp !== 10 && cp !== 13);
      const is_del = (cp === 127);
      const is_c1 = (cp >= 0x80 && cp <= 0x9F);

      if (INVISIBLE_CANDIDATES.has(cp) || is_ascii_ctrl || is_del || is_c1) {
        findings.push({
          index: i,
          codePoint: cp,
          hex: to_hex_u(cp),
          name: INVISIBLE_CANDIDATES.get(cp) || (is_ascii_ctrl ? "ASCII CONTROL" : is_c1 ? "C1 CONTROL" : "DEL"),
          context: safe_slice_context(text, i),
          kind: INVISIBLE_CANDIDATES.has(cp) ? "invisible/space" : "control"
        });
      }
      i += ch.length;
    }
    return findings;
  }

  function detect_bidi_controls(text) {
    const findings = [];
    let i = 0;
    for (const ch of text) {
      const cp = ch.codePointAt(0);
      if (BIDI_CONTROLS.has(cp)) {
        findings.push({ index: i, codePoint: cp, hex: to_hex_u(cp), name: BIDI_CONTROLS.get(cp), context: safe_slice_context(text, i) });
      }
      i += ch.length;
    }

    const open = new Set([0x202A,0x202B,0x202D,0x202E,0x2066,0x2067,0x2068]);
    const close = new Set([0x202C,0x2069]);
    const stack = [];
    const pairIssues = [];

    for (const f of findings) {
      if (open.has(f.codePoint)) stack.push(f);
      else if (close.has(f.codePoint)) {
        if (!stack.length) pairIssues.push({ type: "unmatched_close", at: f.index, hex: f.hex, name: f.name });
        else stack.pop();
      }
    }
    while (stack.length) {
      const f = stack.pop();
      pairIssues.push({ type: "unclosed_open", at: f.index, hex: f.hex, name: f.name });
    }

    return { findings, pairIssues };
  }

  function detect_normalization_diff(text) {
    let nfkc = "";
    try { nfkc = text.normalize("NFKC"); } catch (_) { return { supported: false, differs: false, samples: [] }; }
    if (nfkc === text) return { supported: true, differs: false, samples: [] };

    const samples = [];
    const maxSamples = 8;
    const len = Math.min(text.length, nfkc.length);
    for (let i = 0; i < len && samples.length < maxSamples; i++) {
      if (text[i] !== nfkc[i]) {
        samples.push({
          index: i,
          before: text[i],
          after: nfkc[i],
          before_hex: to_hex_u(text.codePointAt(i)),
          after_hex: to_hex_u(nfkc.codePointAt(i))
        });
      }
    }
    return { supported: true, differs: true, samples, nfkc_preview: nfkc.slice(0, 240) };
  }

  const CONFUSABLES = new Map([
    ["\u0430", { ascii: "a", script: "Cyrillic", note: "CYRILLIC SMALL LETTER A" }],
    ["\u0435", { ascii: "e", script: "Cyrillic", note: "CYRILLIC SMALL LETTER IE" }],
    ["\u043E", { ascii: "o", script: "Cyrillic", note: "CYRILLIC SMALL LETTER O" }],
    ["\u0440", { ascii: "p", script: "Cyrillic", note: "CYRILLIC SMALL LETTER ER" }],
    ["\u0441", { ascii: "c", script: "Cyrillic", note: "CYRILLIC SMALL LETTER ES" }],
    ["\u0445", { ascii: "x", script: "Cyrillic", note: "CYRILLIC SMALL LETTER HA" }],
    ["\u0456", { ascii: "i", script: "Cyrillic", note: "CYRILLIC SMALL LETTER I" }],
    ["\u0406", { ascii: "I", script: "Cyrillic", note: "CYRILLIC CAPITAL LETTER I" }],
    ["\u041D", { ascii: "H", script: "Cyrillic", note: "CYRILLIC CAPITAL LETTER EN" }],
    ["\u0422", { ascii: "T", script: "Cyrillic", note: "CYRILLIC CAPITAL LETTER TE" }],
    ["\u041E", { ascii: "O", script: "Cyrillic", note: "CYRILLIC CAPITAL LETTER O" }],
    ["\u03BF", { ascii: "o", script: "Greek", note: "GREEK SMALL LETTER OMICRON" }],
    ["\u039F", { ascii: "O", script: "Greek", note: "GREEK CAPITAL LETTER OMICRON" }],
    ["\u03B1", { ascii: "a", script: "Greek", note: "GREEK SMALL LETTER ALPHA" }],
    ["\u0391", { ascii: "A", script: "Greek", note: "GREEK CAPITAL LETTER ALPHA" }],
    ["\u03C1", { ascii: "p", script: "Greek", note: "GREEK SMALL LETTER RHO" }],
    ["\u03A1", { ascii: "P", script: "Greek", note: "GREEK CAPITAL LETTER RHO" }]
  ]);

  function detect_homoglyphs_client(text) {
    const findings = [];
    let i = 0;
    for (const ch of text) {
      if (CONFUSABLES.has(ch)) {
        const meta = CONFUSABLES.get(ch);
        findings.push({
          index: i,
          char: ch,
          hex: to_hex_u(ch.codePointAt(0)),
          script: meta.script,
          ascii: meta.ascii,
          note: meta.note,
          context: safe_slice_context(text, i)
        });
      }
      i += ch.length;
    }

    const propEsc = supports_unicode_property_escapes();
    let letters = 0, latin = 0, cyr = 0, grk = 0;

    if (propEsc) {
      for (const ch of text) {
        if (/\p{L}/u.test(ch)) {
          letters++;
          if (/\p{Script=Latin}/u.test(ch)) latin++;
          else if (/\p{Script=Cyrillic}/u.test(ch)) cyr++;
          else if (/\p{Script=Greek}/u.test(ch)) grk++;
        }
      }
    } else {
      for (const ch of text) {
        const cp = ch.codePointAt(0);
        const isLatinish = (cp >= 65 && cp <= 90) || (cp >= 97 && cp <= 122) || (cp >= 192 && cp <= 255);
        if (isLatinish) { letters++; latin++; }
        else if (cp >= 0x0400 && cp <= 0x04FF) { letters++; cyr++; }
        else if (cp >= 0x0370 && cp <= 0x03FF) { letters++; grk++; }
      }
    }

    const mixedScriptFlag = (letters >= 6 && latin / Math.max(letters, 1) >= 0.75 && (cyr + grk) >= 1);
    return { findings, stats: { letters, latin, cyr, grk, mixedScriptFlag } };
  }

  function detect_whitespace_channel(text) {
    const lines = text.split(/\r?\n/);
    let trailingSpaces = 0;
    let trailingTabs = 0;
    let mixedIndent = 0;

    const trailingFindings = [];
    const indentFindings = [];
    const maxLinesReported = 30;

    for (let ln = 0; ln < lines.length; ln++) {
      const line = lines[ln];

      const mTrail = line.match(/([ \t]+)$/);
      if (mTrail) {
        const trail = mTrail[1];
        const spaces = (trail.match(/ /g) || []).length;
        const tabs = (trail.match(/\t/g) || []).length;
        if (spaces) trailingSpaces++;
        if (tabs) trailingTabs++;
        if (trailingFindings.length < maxLinesReported) {
          trailingFindings.push({ line: ln + 1, spaces, tabs, preview: line.slice(0, 140) + (line.length > 140 ? "…" : "") });
        }
      }

      const mIndent = line.match(/^([ \t]+)/);
      if (mIndent) {
        const indent = mIndent[1];
        const spaces = (indent.match(/ /g) || []).length;
        const tabs = (indent.match(/\t/g) || []).length;
        if (tabs && spaces) {
          mixedIndent++;
          if (indentFindings.length < maxLinesReported) {
            indentFindings.push({ line: ln + 1, spaces, tabs, preview: line.slice(0, 140) + (line.length > 140 ? "…" : "") });
          }
        }
      }
    }

    return { lineCount: lines.length, trailingSpaces, trailingTabs, mixedIndent, trailingFindings, indentFindings };
  }

  function bytes_from_binary_string(bin) {
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i) & 0xFF;
    return bytes;
  }

  function normalize_base64_candidate(s, urlSafe) {
    let t = s;
    if (urlSafe) t = t.replace(/-/g, "+").replace(/_/g, "/");
    const mod = t.length % 4;
    if (mod === 2) t += "==";
    else if (mod === 3) t += "=";
    else if (mod === 1) return null;
    return t;
  }

  function looks_like_magic_bytes(bytes) {
    if (bytes.length < 2) return false;
    if (bytes[0] === 0x1F && bytes[1] === 0x8B) return true;
    if (bytes[0] === 0x78 && (bytes[1] === 0x01 || bytes[1] === 0x5E || bytes[1] === 0x9C || bytes[1] === 0xDA)) return true;
    if (bytes.length >= 4 && bytes[0] === 0x50 && bytes[1] === 0x4B && bytes[2] === 0x03 && bytes[3] === 0x04) return true;
    if (bytes.length >= 4 && bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) return true;
    return false;
  }

  function looks_like_utf8_text(bytes) {
    if (typeof TextDecoder === "undefined") return { ok: false };
    try {
      const dec = new TextDecoder("utf-8", { fatal: true });
      const s = dec.decode(bytes);
      if (!s) return { ok: false };

      let printable = 0;
      for (const ch of s) {
        const cp = ch.codePointAt(0);
        const isPrint =
          ch === "\n" || ch === "\r" || ch === "\t" ||
          (cp >= 32 && cp <= 126) || (cp >= 160);
        if (isPrint) printable++;
      }
      const ratio = printable / Math.max(s.length, 1);
      return { ok: ratio > 0.90, ratio, preview: s.slice(0, 220) };
    } catch (_) {
      return { ok: false };
    }
  }

  function decode_base64_candidate(candidate, urlSafe) {
    const norm = normalize_base64_candidate(candidate, urlSafe);
    if (!norm) return { ok: false, reason: "invalid_length" };
    if (norm.length > 20000) return { ok: false, reason: "too_large" };
    try {
      const bin = atob(norm);
      const bytes = bytes_from_binary_string(bin);
      return { ok: true, bytes };
    } catch (_) {
      return { ok: false, reason: "decode_failed" };
    }
  }

  function detect_base64_strict(text, { strict = true } = {}) {
    const stdRe = /(^|[^A-Za-z0-9+/=])([A-Za-z0-9+/]{32,}(?:={0,2}))(?![A-Za-z0-9+/=])/g;

    // IMPORTANT: keep '-' at the end inside the char class to avoid invalid ranges
    const urlRe = /(^|[^A-Za-z0-9_=-])([A-Za-z0-9_-]{43,}(?:={0,2}))(?![A-Za-z0-9_=-])/g;

    const findings = [];
    const max = 120;

    function handle_match(m, urlSafe) {
      const lead = m[1] || "";
      const cand = m[2];
      const start = (m.index ?? 0) + lead.length;

      const dec = decode_base64_candidate(cand, urlSafe);
      if (!dec.ok) return;

      if (!strict) {
        findings.push({ index: start, candidate: cand, kind: urlSafe ? "base64url" : "base64", confidence: "low" });
        return;
      }

      const bytes = dec.bytes;
      const magic = looks_like_magic_bytes(bytes);
      const utf8 = looks_like_utf8_text(bytes);

      if (magic || utf8.ok) {
        findings.push({
          index: start,
          candidate: cand,
          kind: urlSafe ? "base64url" : "base64",
          confidence: "high",
          magic: magic ? "yes" : "no",
          utf8_ratio: utf8.ratio ?? null,
          decoded_preview: utf8.preview ?? null
        });
      }
    }

    for (const m of text.matchAll(stdRe)) {
      if (findings.length >= max) break;
      handle_match(m, false);
    }
    for (const m of text.matchAll(urlRe)) {
      if (findings.length >= max) break;
      handle_match(m, true);
    }

    return findings;
  }

  function detect_hex_escapes(text) {
    const findings = [];
    const max = 200;

    for (const m of text.matchAll(/\b0x[0-9A-Fa-f]{8,}\b/g)) {
      findings.push({ kind: "0x", index: m.index ?? 0, value: m[0], context: safe_slice_context(text, m.index ?? 0) });
      if (findings.length >= max) return findings;
    }

    let mx;
    const rex = /\\x[0-9A-Fa-f]{2}/g;
    while ((mx = rex.exec(text)) !== null) {
      findings.push({ kind: "\\x", index: mx.index, value: mx[0], context: safe_slice_context(text, mx.index) });
      if (findings.length >= max) return findings;
    }

    let mu;
    const reu = /\\u\{[0-9A-Fa-f]{1,6}\}|\\u[0-9A-Fa-f]{4}/g;
    while ((mu = reu.exec(text)) !== null) {
      findings.push({ kind: "\\u", index: mu.index, value: mu[0], context: safe_slice_context(text, mu.index) });
      if (findings.length >= max) return findings;
    }

    return findings;
  }

  function detect_percent_encoding(text) {
    const hits = [];
    const re = /%[0-9A-Fa-f]{2}/g;
    let m;
    while ((m = re.exec(text)) !== null) {
      hits.push({ index: m.index, chunk: m[0], context: safe_slice_context(text, m.index) });
      if (hits.length >= 200) break;
    }
    return { count: hits.length, hits };
  }

  function shannon_entropy(s) {
    const n = s.length;
    if (!n) return 0;
    const freq = new Map();
    for (const ch of s) freq.set(ch, (freq.get(ch) || 0) + 1);
    let h = 0;
    for (const c of freq.values()) {
      const p = c / n;
      h -= p * Math.log2(p);
    }
    return h;
  }

  function detect_high_entropy_runs(text) {
    const runs = [];
    const re = /[A-Za-z0-9+/_=-]{40,}/g;
    let m;
    while ((m = re.exec(text)) !== null) {
      const chunk = m[0];
      const h = shannon_entropy(chunk.slice(0, 220));
      if (h > 4.35) {
        runs.push({
          index: m.index,
          length: chunk.length,
          entropy: h,
          preview: chunk.slice(0, 120) + (chunk.length > 120 ? "…" : ""),
          context: safe_slice_context(text, m.index)
        });
      }
      if (runs.length >= 100) break;
    }
    return runs;
  }

  const TRACKING_KEYS = new Set([
    "srsltid","gclid","fbclid","msclkid","yclid",
    "utm_source","utm_medium","utm_campaign","utm_term","utm_content"
  ]);

  function analyze_url_tracking(url) {
    try {
      const u = new URL(url);
      const out = [];
      for (const [k, v] of u.searchParams.entries()) {
        const key = k.toLowerCase();
        const val = v || "";
        const isKnownKey = TRACKING_KEYS.has(key);
        const looksB64Url = /^[A-Za-z0-9_-]{20,}={0,2}$/.test(val);
        const ent = (val.length >= 20) ? shannon_entropy(val) : 0;
        const trackingLike = isKnownKey || (looksB64Url && ent > 4.2);

        if (trackingLike) {
          out.push({
            key: k,
            length: val.length,
            entropy: ent,
            preview: val.slice(0, 70) + (val.length > 70 ? "…" : ""),
            reason: isKnownKey ? "known_tracking_key" : "high_entropy_token"
          });
        }
      }
      return out;
    } catch (_) {
      return [];
    }
  }

  function split_sentences(text) {
    const out = [];
    let buf = "";
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      buf += ch;
      if (ch === "." || ch === "!" || ch === "?") {
        const next = text[i + 1] || "";
        if (next === "" || /\s/.test(next)) {
          out.push(buf);
          buf = "";
        }
      }
    }
    if (buf.trim().length) out.push(buf);
    return out.map(s => s.trim()).filter(Boolean);
  }

  function first_letter(sentence) {
    const propEsc = supports_unicode_property_escapes();
    if (propEsc) {
      const m = sentence.match(/\p{L}/u);
      return m ? m[0] : "";
    }
    const m = sentence.match(/[A-Za-z]/);
    return m ? m[0] : "";
  }

  function strip_comment_prefix(line) {
    return line.replace(/^\s*(\/\/+|#|\*+|\/\*+|\*\/)\s?/, "");
  }

  function detect_acrostics(text) {
    const sentences = split_sentences(text);
    const sentenceInitials = [];
    for (const s of sentences) {
      const f = first_letter(s);
      if (f) sentenceInitials.push(f);
    }

    const lines = text.split(/\r?\n/);
    const lineInitials = [];
    for (const line of lines) {
      const clean = strip_comment_prefix(line).trim();
      if (!clean) continue;
      const f = first_letter(clean);
      if (f) lineInitials.push(f);
    }

    const HINT_WORDS = ["HELP","SOS","TEST","OPENAI","GPT","CODE","HELLO"];
    function find_hits(initials) {
      const upper = initials.toUpperCase();
      const hits = [];
      for (const w of HINT_WORDS) {
        const idx = upper.indexOf(w);
        if (idx !== -1) hits.push({ word: w, at: idx });
      }
      return { upper, hits };
    }

    const sInit = sentenceInitials.join("");
    const lInit = lineInitials.join("");
    const sHits = find_hits(sInit);
    const lHits = find_hits(lInit);

    const suspicious = (sInit.length >= 4 && sHits.hits.length > 0) || (lInit.length >= 4 && lHits.hits.length > 0);

    return {
      sentenceCount: sentences.length,
      lineCount: lines.length,
      sentenceInitials: sInit,
      lineInitials: lInit,
      sentenceHits: sHits.hits,
      lineHits: lHits.hits,
      suspicious
    };
  }

  function ngram_counts(tokens, n) {
    const map = new Map();
    for (let i = 0; i <= tokens.length - n; i++) {
      const gram = tokens.slice(i, i + n).join(" ");
      map.set(gram, (map.get(gram) || 0) + 1);
    }
    return map;
  }

  function top_n_freq(map, n = 10) {
    return [...map.entries()].sort((a, b) => b[1] - a[1]).slice(0, n);
  }

  function shannon_entropy_from_freq(freqMap, total) {
    if (total <= 0) return 0;
    let h = 0;
    for (const c of freqMap.values()) {
      const p = c / total;
      h -= p * Math.log2(p);
    }
    return h;
  }

  function detect_repetition_uniformity(text) {
    const tokensRaw = tokenize(text);
    const tokens = tokensRaw.map(t => t.toLowerCase());
    const total = tokens.length;

    const freq = new Map();
    for (const t of tokens) freq.set(t, (freq.get(t) || 0) + 1);

    const unique = freq.size;
    const ttr = total ? unique / total : 0;
    const entropy = shannon_entropy_from_freq(freq, total);

    const topWords = top_n_freq(freq, 10);
    const bigrams = ngram_counts(tokens, 2);
    const trigrams = ngram_counts(tokens, 3);
    const topBigrams = top_n_freq(bigrams, 8).filter(([, c]) => c >= 2);
    const topTrigrams = top_n_freq(trigrams, 8).filter(([, c]) => c >= 2);

    const top1 = topWords.length ? topWords[0][1] : 0;
    const top1Ratio = total ? top1 / total : 0;

    const flags = [];
    if (total >= 80 && ttr < 0.25) flags.push("Low lexical variety for a long input (TTR < 0.25).");
    if (total >= 50 && top1Ratio > 0.08) flags.push("One token dominates (> 8% of all tokens).");
    if (topTrigrams.length) flags.push("Repeated trigrams detected (copy/paste or template-like text).");
    if (topBigrams.length && !topTrigrams.length) flags.push("Repeated bigrams detected.");
    if (total >= 60 && entropy < 5.0) flags.push("Low token distribution entropy (more uniform than typical prose).");

    return { total, unique, ttr, entropy, topWords, topBigrams, topTrigrams, flags };
  }

  function detect_explicit_markers(text) {
    const patterns = [
      /\b(chatgpt|openai|anthropic|claude|gemini|copilot)\b/i,
      /\b(generated\s+by|written\s+by|created\s+with)\b/i,
      /\b(ai[- ]generated|llm|large language model)\b/i,
      /\b(watermark|steganograph|stego)\b/i,
      /(?:^|\s)```/m
    ];
    const hits = [];
    for (const re of patterns) {
      const m = text.match(re);
      if (m) hits.push({ match: m[0], index: m.index ?? 0, context: safe_slice_context(text, m.index ?? 0) });
    }
    return hits;
  }

  // -------------------------
  // Code identifier anomalies (fixed to avoid prose + umlaut noise)
  // -------------------------

  function extract_code_segments(text, inputType) {
    const segments = [];

    // Prefer fenced code blocks (Markdown)
    const fenceRe = /```[^\n]*\n([\s\S]*?)```/g;
    for (const m of text.matchAll(fenceRe)) {
      const seg = m[1] || "";
      if (seg.trim().length) segments.push(seg);
    }

    if (segments.length) return segments;

    // If the whole input is code-like, treat it as code
    if (inputType === "code" || inputType === "code-ish") {
      return [text];
    }

    // Otherwise: no code to scan
    return [];
  }

  function detect_identifier_anomalies(text, inputType) {
    const segments = extract_code_segments(text, inputType);
    if (!segments.length) {
      return { skipped: true, reason: "Input is not code-like and contains no fenced code blocks." };
    }

    const propEsc = supports_unicode_property_escapes();
    const re = propEsc ? /[$_\p{L}][$_\p{L}\p{N}]*/gu : /[$_A-Za-z][$_A-Za-z0-9]*/g;

    const findings = [];
    const max = 200;

    for (const seg of segments) {
      for (const m of seg.matchAll(re)) {
        if (findings.length >= max) break;

        const ident = m[0];
        const idx = m.index ?? 0;

        let confusableHits = [];
        let letters = 0, latin = 0, cyr = 0, grk = 0, other = 0;

        for (const ch of ident) {
          const cp = ch.codePointAt(0);

          if (CONFUSABLES.has(ch)) {
            confusableHits.push({ ch, hex: to_hex_u(cp), meta: CONFUSABLES.get(ch) });
          }

          if (propEsc && /\p{L}/u.test(ch)) {
            letters++;
            if (/\p{Script=Latin}/u.test(ch)) latin++;
            else if (/\p{Script=Cyrillic}/u.test(ch)) cyr++;
            else if (/\p{Script=Greek}/u.test(ch)) grk++;
            else other++;
          } else if (!propEsc) {
            // Rough fallback script classification
            if ((cp >= 65 && cp <= 90) || (cp >= 97 && cp <= 122) || (cp >= 0x00C0 && cp <= 0x024F)) { letters++; latin++; }
            else if (cp >= 0x0400 && cp <= 0x04FF) { letters++; cyr++; }
            else if (cp >= 0x0370 && cp <= 0x03FF) { letters++; grk++; }
          }
        }

        const scriptsUsed = (latin > 0) + (cyr > 0) + (grk > 0) + (other > 0);
        const mixedScript = letters >= 2 && scriptsUsed >= 2;

        // IMPORTANT: do NOT flag purely Latin identifiers (even if they contain umlauts)
        const hasNonLatinLetters = (cyr + grk + other) > 0;

        if (confusableHits.length || mixedScript || hasNonLatinLetters) {
          findings.push({
            index: idx,
            identifier: ident,
            mixedScript,
            confusableHits,
            hasNonLatinLetters,
            scripts: { latin, cyr, grk, other }
          });
        }
      }
      if (findings.length >= max) break;
    }

    return findings;
  }

  // -------------------------
  // Client orchestrator
  // -------------------------

  function client_analyze(rawText, settings, selected, inputType) {
    const urls = extract_urls(rawText);
    const textForPayload = settings.maskUrls ? mask_urls(rawText, urls) : rawText;

    const out = { client: { urls } };

    if (selected.has("unicode_specials")) out.client.unicode_specials = detect_unicode_specials(rawText);
    if (selected.has("unicode_bidi")) out.client.unicode_bidi = detect_bidi_controls(rawText);
    if (selected.has("unicode_norm")) out.client.unicode_norm = detect_normalization_diff(rawText);
    if (selected.has("unicode_homoglyph")) out.client.unicode_homoglyph = detect_homoglyphs_client(rawText);

    if (selected.has("stego_whitespace")) out.client.stego_whitespace = detect_whitespace_channel(rawText);

    if (selected.has("payload_base64")) out.client.payload_base64 = detect_base64_strict(textForPayload, { strict: settings.strictBase64 });
    if (selected.has("payload_hex")) out.client.payload_hex = detect_hex_escapes(textForPayload);
    if (selected.has("payload_urlenc")) out.client.payload_urlenc = detect_percent_encoding(textForPayload);
    if (selected.has("payload_entropy")) out.client.payload_entropy = detect_high_entropy_runs(textForPayload);

    if (selected.has("url_tracking") && settings.analyzeUrls) {
      const tracking = [];
      for (const u of urls) {
        const toks = analyze_url_tracking(u.url);
        if (toks.length) tracking.push({ url: u.url, index: u.index, tokens: toks });
      }
      out.client.url_tracking = tracking;
    } else {
      out.client.url_tracking = [];
    }

    if (selected.has("structure_acrostic")) out.client.structure_acrostic = detect_acrostics(rawText);
    if (selected.has("style_repetition")) out.client.style_repetition = detect_repetition_uniformity(rawText);

    if (selected.has("explicit_markers")) {
      const markerText = settings.maskUrls ? textForPayload : rawText;
      out.client.explicit_markers = detect_explicit_markers(markerText);
    }

    if (selected.has("code_identifier")) out.client.code_identifier = detect_identifier_anomalies(rawText, inputType);

    return out;
  }

  async function fetch_with_timeout(url, options, timeoutMs) {
    if (typeof AbortController === "undefined") {
      return fetch(url, options);
    }
    const ctrl = new AbortController();
    const id = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      return await fetch(url, { ...options, signal: ctrl.signal });
    } finally {
      clearTimeout(id);
    }
  }

  async function server_analyze(text, selected, settings) {
    const payload = { text, selected: [...selected], settings };
    const res = await fetch_with_timeout(API_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    }, API_TIMEOUT_MS);

    if (!res.ok) throw new Error("API HTTP " + res.status);

    let data;
    try { data = await res.json(); }
    catch (_) { throw new Error("API did not return JSON (check PHP errors/logs)."); }

    if (!data || data.ok !== true) throw new Error("API returned an error.");
    return data;
  }

  async function update_api_status() {
    elApiDot.className = "dot warn";
    elApiText.textContent = "API: checking…";
    state.apiReachable = false;

    try {
      const res = await fetch_with_timeout(API_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: "", selected: [], settings: {} })
      }, 900);

      if (!res.ok) throw new Error("HTTP " + res.status);

      const data = await res.json();
      if (data && data.ok === true) {
        state.apiReachable = true;
        elApiDot.className = "dot ok";
        elApiText.textContent = "API: reachable";
        return;
      }
      throw new Error("not ok");
    } catch (_) {
      state.apiReachable = false;
      elApiDot.className = "dot warn";
      elApiText.textContent = "API: unreachable (client-only)";
    }
  }

  function summarize_server_caps(meta) {
    if (!meta) return "–";
    const caps = [];
    if (meta.intl_available) caps.push("intl");
    if (meta.spoofchecker_available) caps.push("Spoofchecker");
    if (meta.intlchar_available) caps.push("IntlChar");
    if (meta.normalizer_available) caps.push("Normalizer");
    return caps.length ? caps.join(", ") : "basic PHP only";
  }

  function badge_for_count(count, hint = null) {
    const b = document.createElement("span");
    b.className = "badge";
    if (count === 0) { b.classList.add("ok"); b.textContent = "No findings"; }
    else if (count <= 2) { b.classList.add("warn"); b.textContent = `${count} finding${count === 1 ? "" : "s"}`; }
    else { b.classList.add("bad"); b.textContent = `${count} findings`; }
    if (hint) b.title = hint;
    return b;
  }

  function render_result_block(title, badgeEl, bodyEl) {
    const wrap = document.createElement("div");
    wrap.className = "res";
    const head = document.createElement("div");
    head.className = "resHead";
    const t = document.createElement("div");
    t.className = "resTitle";
    t.textContent = title;
    head.appendChild(t);
    head.appendChild(badgeEl);
    const body = document.createElement("div");
    body.className = "resBody";
    body.appendChild(bodyEl);
    wrap.appendChild(head);
    wrap.appendChild(body);
    return wrap;
  }

  function render_list(items, formatterHtml) {
    const ul = document.createElement("ul");
    ul.className = "list";
    for (const it of items) {
      const li = document.createElement("li");
      li.innerHTML = formatterHtml(it);
      ul.appendChild(li);
    }
    return ul;
  }

  function render_results(res, inputType, apiUsed, settings) {
    elResults.innerHTML = "";
    const urlsCount = res.client.urls?.length || 0;

    // (Other blocks unchanged for brevity in explanation; fully included below via this file.)
    // To keep your copy/paste easy: this render section remains functionally identical
    // except for the "Code identifier anomalies" block at the end (now supports "skipped").

    // Unicode specials
    if (state.selected.has("unicode_specials")) {
      const f = res.client.unicode_specials || [];
      const body = document.createElement("div");
      if (!f.length) body.textContent = "No common invisible/space/control characters found (client list).";
      else body.appendChild(render_list(f, (x) =>
        `${as_mono(x.hex)} ${escape_html(x.name)} at index ${as_mono(String(x.index))} · context: ${as_mono(x.context)}`
      ));

      if (apiUsed && res.server?.unicode_scan?.length) {
        const p = document.createElement("div");
        p.style.marginTop = "10px";
        p.innerHTML = `<div class="small">Server (IntlChar) additional findings:</div>`;
        body.appendChild(p);
        body.appendChild(render_list(res.server.unicode_scan.slice(0, 60), (x) =>
          `${as_mono(x.hex)} ${escape_html(x.name)} (${escape_html(x.category)}) at charIndex ${as_mono(String(x.char_index))}`
        ));
      }

      elResults.appendChild(render_result_block(
        "Unicode invisibles / format / control chars",
        badge_for_count(f.length + (apiUsed ? (res.server?.unicode_scan?.length || 0) : 0)),
        body
      ));
    }

    // Bidi
    if (state.selected.has("unicode_bidi")) {
      const b = res.client.unicode_bidi || { findings: [], pairIssues: [] };
      const f = b.findings || [];
      const body = document.createElement("div");

      if (!f.length) body.textContent = "No Bidi/direction control characters found.";
      else {
        body.appendChild(render_list(f, (x) => `${as_mono(x.hex)} ${escape_html(x.name)} at idx ${as_mono(String(x.index))} · ${as_mono(x.context)}`));
        if (b.pairIssues?.length) {
          const p = document.createElement("div");
          p.style.marginTop = "8px";
          p.innerHTML = `<div class="small">Pairing issues (heuristic):</div>`;
          body.appendChild(p);
          body.appendChild(render_list(b.pairIssues, (x) => `${escape_html(x.type)} at ${as_mono(String(x.at))} (${as_mono(x.hex)} ${escape_html(x.name)})`));
        }
      }

      if (apiUsed && res.server?.bidi_pairing?.issues?.length) {
        const p = document.createElement("div");
        p.style.marginTop = "10px";
        p.innerHTML = `<div class="small">Server per-line pairing issues:</div>`;
        body.appendChild(p);
        body.appendChild(render_list(res.server.bidi_pairing.issues.slice(0, 60), (x) =>
          `line ${as_mono(String(x.line))}: ${escape_html(x.issue)} (${as_mono(x.hex)} ${escape_html(x.name)})`
        ));
      }

      elResults.appendChild(render_result_block(
        "Bidi / direction controls (Trojan Source)",
        badge_for_count(f.length + (apiUsed ? (res.server?.bidi_pairing?.issues?.length || 0) : 0)),
        body
      ));
    }

    // Normalization
    if (state.selected.has("unicode_norm")) {
      const n = res.client.unicode_norm || { supported: false, differs: false, samples: [] };
      const body = document.createElement("div");

      const badge = (() => {
        const b = document.createElement("span");
        b.className = "badge";
        if (!n.supported) { b.classList.add("warn"); b.textContent = "Not supported"; }
        else if (!n.differs) { b.classList.add("ok"); b.textContent = "No diff"; }
        else { b.classList.add("warn"); b.textContent = "Differs"; }
        return b;
      })();

      if (!n.supported) body.textContent = "String.prototype.normalize not supported in this browser.";
      else if (!n.differs) body.textContent = "NFKC normalization does not change the string.";
      else {
        const info = document.createElement("div");
        info.className = "kvs small";
        info.innerHTML =
          `<div class="k">NFKC differs</div><div class="v">Yes</div>` +
          `<div class="k">NFKC preview</div><div class="v mono">${escape_html(n.nfkc_preview || "")}</div>`;
        body.appendChild(info);

        if (n.samples?.length) {
          const p = document.createElement("div");
          p.style.marginTop = "8px";
          p.textContent = "First differing positions (sample):";
          body.appendChild(p);
          body.appendChild(render_list(n.samples, (x) =>
            `idx ${as_mono(String(x.index))}: ${as_mono(x.before)} ${as_mono(x.before_hex)} → ${as_mono(x.after)} ${as_mono(x.after_hex)}`
          ));
        }
      }

      if (apiUsed && res.server?.normalization?.available) {
        const p = document.createElement("div");
        p.style.marginTop = "10px";
        p.innerHTML = `<div class="small">Server Normalizer: differs=${escape_html(String(res.server.normalization.differs))}</div>`;
        body.appendChild(p);
      }

      elResults.appendChild(render_result_block("Unicode normalization tricks (NFKC diff)", badge, body));
    }

    // Homoglyphs
    if (state.selected.has("unicode_homoglyph")) {
      const hg = res.client.unicode_homoglyph || { findings: [], stats: {} };
      const f = hg.findings || [];
      const body = document.createElement("div");

      const stats = hg.stats || {};
      const s = document.createElement("div");
      s.className = "kvs small";
      s.innerHTML =
        `<div class="k">Letters</div><div class="v">${stats.letters ?? 0}</div>` +
        `<div class="k">Latin</div><div class="v">${stats.latin ?? 0}</div>` +
        `<div class="k">Cyrillic</div><div class="v">${stats.cyr ?? 0}</div>` +
        `<div class="k">Greek</div><div class="v">${stats.grk ?? 0}</div>` +
        `<div class="k">Mixed-script</div><div class="v">${stats.mixedScriptFlag ? "Yes (heuristic)" : "No"}</div>`;
      body.appendChild(s);

      if (f.length) {
        const p = document.createElement("div");
        p.style.marginTop = "8px";
        p.textContent = "Confusable characters found (client baseline list):";
        body.appendChild(p);
        body.appendChild(render_list(f, (x) =>
          `char ${as_mono(x.char)} (${as_mono(x.hex)}, ${escape_html(x.script)}) ≈ ${as_mono(x.ascii)} · idx ${as_mono(String(x.index))}`
        ));
      } else {
        const p = document.createElement("div");
        p.style.marginTop = "8px";
        p.textContent = "No hits in the small built-in confusables list.";
        body.appendChild(p);
      }

      if (apiUsed && res.server?.spoof_tokens) {
        const st = res.server.spoof_tokens;
        const p = document.createElement("div");
        p.style.marginTop = "10px";
        p.innerHTML = `<div class="small">Server ICU Spoofchecker (token-scoped): suspicious=${escape_html(String(st.suspicious_count))} / scanned=${escape_html(String(st.scanned_count))}</div>`;
        body.appendChild(p);

        if (st.suspicious?.length) {
          body.appendChild(render_list(st.suspicious.slice(0, 40), (x) =>
            `token ${as_mono(x.token)} · reason=${escape_html(x.reason)}${x.skeleton ? ` · skeleton=${as_mono(x.skeleton)}` : ""}`
          ));
        }
      }

      const badge = badge_for_count(f.length + (apiUsed ? (res.server?.spoof_tokens?.suspicious_count || 0) : 0));
      elResults.appendChild(render_result_block("Homoglyphs / mixed scripts (confusables)", badge, body));
    }

    // Whitespace channel
    if (state.selected.has("stego_whitespace")) {
      const w = res.client.stego_whitespace || {};
      const count = (w.trailingSpaces || 0) + (w.trailingTabs || 0) + (w.mixedIndent || 0);
      const body = document.createElement("div");

      const info = document.createElement("div");
      info.className = "kvs small";
      info.innerHTML =
        `<div class="k">Lines</div><div class="v">${w.lineCount ?? 0}</div>` +
        `<div class="k">Trailing spaces lines</div><div class="v">${w.trailingSpaces ?? 0}</div>` +
        `<div class="k">Trailing tabs lines</div><div class="v">${w.trailingTabs ?? 0}</div>` +
        `<div class="k">Mixed indent lines</div><div class="v">${w.mixedIndent ?? 0}</div>`;
      body.appendChild(info);

      if (w.trailingFindings?.length) {
        const p = document.createElement("div");
        p.style.marginTop = "8px";
        p.textContent = "Lines with trailing whitespace:";
        body.appendChild(p);
        body.appendChild(render_list(w.trailingFindings.slice(0, 20), (x) =>
          `line ${as_mono(String(x.line))}: spaces=${as_mono(String(x.spaces))}, tabs=${as_mono(String(x.tabs))} · ${as_mono(x.preview)}`
        ));
      }

      if (w.indentFindings?.length) {
        const p = document.createElement("div");
        p.style.marginTop = "8px";
        p.textContent = "Lines with mixed indentation (tabs + spaces):";
        body.appendChild(p);
        body.appendChild(render_list(w.indentFindings.slice(0, 20), (x) =>
          `line ${as_mono(String(x.line))}: spaces=${as_mono(String(x.spaces))}, tabs=${as_mono(String(x.tabs))} · ${as_mono(x.preview)}`
        ));
      }

      elResults.appendChild(render_result_block("Whitespace channel signals", badge_for_count(count), body));
    }

    // Base64
    if (state.selected.has("payload_base64")) {
      const f = res.client.payload_base64 || [];
      const body = document.createElement("div");

      if (!f.length) {
        body.innerHTML = `No Base64/Base64URL payloads detected (<b>strict</b> criteria).<br/><span class="small">URLs masked=${escape_html(String(settings.maskUrls))}, URLs found=${escape_html(String(urlsCount))}</span>`;
      } else {
        body.appendChild(render_list(f, (x) => {
          const meta = [];
          meta.push(`kind=${x.kind}`);
          meta.push(`confidence=${x.confidence}`);
          if (x.magic === "yes") meta.push("magic-bytes=yes");
          if (x.utf8_ratio != null) meta.push(`utf8_ratio=${x.utf8_ratio.toFixed(3)}`);
          return `idx ${as_mono(String(x.index))} · ${meta.map(as_mono).join(" ")} · cand ${as_mono(x.candidate.slice(0, 80) + (x.candidate.length > 80 ? "…" : ""))}` +
            (x.decoded_preview ? ` · decoded ${as_mono(x.decoded_preview)}` : "");
        }));
      }

      if (apiUsed && res.server?.base64?.length) {
        const p = document.createElement("div");
        p.style.marginTop = "10px";
        p.innerHTML = `<div class="small">Server strict Base64 findings:</div>`;
        body.appendChild(p);
        body.appendChild(render_list(res.server.base64.slice(0, 40), (x) =>
          `idx ${as_mono(String(x.index))} · kind=${as_mono(x.kind)} · ${as_mono(x.candidate.slice(0, 80) + (x.candidate.length > 80 ? "…" : ""))}`
        ));
      }

      elResults.appendChild(render_result_block("Base64 / Base64URL payloads (strict)", badge_for_count(f.length + (apiUsed ? (res.server?.base64?.length || 0) : 0)), body));
    }

    // Hex/escapes
    if (state.selected.has("payload_hex")) {
      const f = res.client.payload_hex || [];
      const body = document.createElement("div");
      if (!f.length) body.textContent = "No obvious hex blobs or escape sequences found (payload text may have URLs masked).";
      else body.appendChild(render_list(f.slice(0, 80), (x) =>
        `${escape_html(x.kind)} at idx ${as_mono(String(x.index))} · ${as_mono(x.value)}`
      ));
      elResults.appendChild(render_result_block("Hex / escaped payloads", badge_for_count(f.length), body));
    }

    // Percent encoding
    if (state.selected.has("payload_urlenc")) {
      const u = res.client.payload_urlenc || { count: 0, hits: [] };
      const body = document.createElement("div");
      if (!u.count) body.textContent = "No %xx patterns found (payload text may have URLs masked).";
      else body.appendChild(render_list(u.hits.slice(0, 40), (x) =>
        `idx ${as_mono(String(x.index))} · ${as_mono(x.chunk)}`
      ));
      elResults.appendChild(render_result_block("Percent-encoding payloads (%xx)", badge_for_count(u.count), body));
    }

    // High entropy runs
    if (state.selected.has("payload_entropy")) {
      const f = res.client.payload_entropy || [];
      const body = document.createElement("div");
      if (!f.length) body.textContent = "No high-entropy runs found (URLs masked by default).";
      else body.appendChild(render_list(f.slice(0, 40), (x) =>
        `idx ${as_mono(String(x.index))} · len ${as_mono(String(x.length))} · entropy ${as_mono(x.entropy.toFixed(2))} · ${as_mono(x.preview)}`
      ));
      elResults.appendChild(render_result_block("High-entropy runs (URLs masked)", badge_for_count(f.length), body));
    }

    // URL tracking
    if (state.selected.has("url_tracking")) {
      const t = res.client.url_tracking || [];
      const body = document.createElement("div");
      if (!t.length) body.textContent = "No tracking-like URL tokens detected (or URL analysis disabled).";
      else {
        body.appendChild(render_list(t.slice(0, 20), (x) => {
          const tokenLines = x.tokens.slice(0, 8).map(tok =>
            `${as_mono(tok.key)} len=${as_mono(String(tok.length))} ent=${as_mono(tok.entropy.toFixed(2))} reason=${as_mono(tok.reason)} val=${as_mono(tok.preview)}`
          ).join("<br/>");
          return `URL ${as_mono(x.url.slice(0, 90) + (x.url.length > 90 ? "…" : ""))}<br/>${tokenLines}`;
        }));
      }
      elResults.appendChild(render_result_block("URL tracking-like tokens", badge_for_count(t.reduce((n, x) => n + x.tokens.length, 0)), body));
    }

    // Acrostics
    if (state.selected.has("structure_acrostic")) {
      const a = res.client.structure_acrostic || {};
      const hitsCount = (a.sentenceHits?.length || 0) + (a.lineHits?.length || 0);
      const badge = (() => {
        const b = document.createElement("span");
        b.className = "badge";
        if (!a.sentenceInitials && !a.lineInitials) { b.classList.add("ok"); b.textContent = "No data"; }
        else if (a.suspicious || hitsCount) { b.classList.add("warn"); b.textContent = "Suspicious"; }
        else { b.classList.add("ok"); b.textContent = "Informational"; }
        return b;
      })();

      const body = document.createElement("div");
      const info = document.createElement("div");
      info.className = "kvs small";
      info.innerHTML =
        `<div class="k">Sentence initials</div><div class="v mono">${escape_html(a.sentenceInitials || "–")}</div>` +
        `<div class="k">Line/comment initials</div><div class="v mono">${escape_html(a.lineInitials || "–")}</div>` +
        `<div class="k">Sentence hits</div><div class="v mono">${escape_html((a.sentenceHits || []).map(h => h.word).join(", ") || "–")}</div>` +
        `<div class="k">Line hits</div><div class="v mono">${escape_html((a.lineHits || []).map(h => h.word).join(", ") || "–")}</div>`;
      body.appendChild(info);

      elResults.appendChild(render_result_block("Acrostics (sentences/lines/comments)", badge, body));
    }

    // Repetition / uniformity
    if (state.selected.has("style_repetition")) {
      const u = res.client.style_repetition || {};
      const flags = u.flags || [];
      const badge = (() => {
        const b = document.createElement("span");
        b.className = "badge";
        if (!u.total) { b.classList.add("ok"); b.textContent = "No text"; }
        else if (!flags.length) { b.classList.add("ok"); b.textContent = "Unremarkable"; }
        else if (flags.length <= 2) { b.classList.add("warn"); b.textContent = "Hints"; }
        else { b.classList.add("bad"); b.textContent = "Noticeable"; }
        return b;
      })();

      const body = document.createElement("div");
      const info = document.createElement("div");
      info.className = "kvs small";
      info.innerHTML =
        `<div class="k">Tokens</div><div class="v">${u.total ?? 0}</div>` +
        `<div class="k">Unique</div><div class="v">${u.unique ?? 0}</div>` +
        `<div class="k">TTR</div><div class="v mono">${(u.ttr ?? 0).toFixed(3)}</div>` +
        `<div class="k">Entropy</div><div class="v mono">${(u.entropy ?? 0).toFixed(3)}</div>`;
      body.appendChild(info);

      if (flags.length) {
        const p = document.createElement("div");
        p.style.marginTop = "8px";
        p.textContent = "Heuristic flags:";
        body.appendChild(p);
        body.appendChild(render_list(flags, (x) => escape_html(x)));
      }

      elResults.appendChild(render_result_block("Repetition / uniformity heuristics", badge, body));
    }

    // Explicit markers
    if (state.selected.has("explicit_markers")) {
      const f = res.client.explicit_markers || [];
      const body = document.createElement("div");
      if (!f.length) body.textContent = "No obvious explicit AI/tool markers found (URLs masked by default).";
      else body.appendChild(render_list(f.slice(0, 40), (x) =>
        `hit ${as_mono(x.match)} · idx ${as_mono(String(x.index))} · ${as_mono(x.context)}`
      ));
      elResults.appendChild(render_result_block("Explicit AI/tool markers", badge_for_count(f.length), body));
    }

    // Code identifiers (fixed rendering: supports "skipped")
    if (state.selected.has("code_identifier")) {
      const r = res.client.code_identifier;

      // Skipped
      if (r && typeof r === "object" && r.skipped) {
        const body = document.createElement("div");
        body.textContent = `Skipped: ${r.reason}`;
        const b = document.createElement("span");
        b.className = "badge ok";
        b.textContent = "Skipped";
        elResults.appendChild(render_result_block("Code identifier anomalies (mixed scripts/confusables)", b, body));
      } else {
        const f = Array.isArray(r) ? r : [];
        const body = document.createElement("div");
        if (!f.length) {
          body.textContent = "No suspicious code identifiers found (non-Latin letters, mixed scripts, confusables).";
        } else {
          body.appendChild(render_list(f.slice(0, 50), (x) => {
            const notes = [];
            if (x.mixedScript) notes.push("mixed-script");
            if (x.hasNonLatinLetters) notes.push("non-Latin letters");
            if (x.confusableHits?.length) notes.push("confusables");

            const conf = (x.confusableHits || []).slice(0, 5)
              .map(h => `${h.ch}(${h.hex}≈${h.meta.ascii})`).join(", ");

            return `idx ${as_mono(String(x.index))} · ident ${as_mono(x.identifier)} · ${escape_html(notes.join(", ") || "–")}` +
              (conf ? ` · ${as_mono(conf)}` : "");
          }));
        }
        elResults.appendChild(render_result_block("Code identifier anomalies (mixed scripts/confusables)", badge_for_count(f.length), body));
      }
    }
  }

  async function run_analysis() {
    clear_error();

    if (!has_text()) {
      update_run_button_state();
      return;
    }

    const rawText = elInput.value || "";
    elLastRun.textContent = now_local_string();

    const inputType = classify_input(rawText);
    elInputType.textContent = inputType;

    const tokens = tokenize(rawText);
    elTokenInfo.textContent = `${tokens.length} tokens (heuristic)`;

    const settings = {
      maskUrls: elMaskUrls.checked,
      strictBase64: elStrictBase64.checked,
      analyzeUrls: elAnalyzeUrls.checked
    };

    let clientRes;
    try {
      clientRes = client_analyze(rawText, settings, state.selected, inputType);
    } catch (e) {
      show_error("Client analysis failed: " + (e?.message || String(e)));
      return;
    }

    let serverRes = null;
    let apiUsed = false;

    if (elUseApi.checked && state.apiReachable) {
      try {
        serverRes = await server_analyze(rawText, state.selected, settings);
        apiUsed = true;
      } catch (e) {
        apiUsed = false;
        show_error((e?.message || String(e)) + " (continuing with client-only results)");
      }
    }

    elApiUsed.textContent = apiUsed ? `Yes (${summarize_server_caps(serverRes?.meta)})` : "No";

    const merged = { ...clientRes };
    if (serverRes?.server) merged.server = serverRes.server;

    render_results(merged, inputType, apiUsed, settings);
  }

  function render_method_chips() {
    elMethodChips.innerHTML = "";
    for (const m of METHODS) {
      const label = document.createElement("label");
      label.className = "chip";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = state.selected.has(m.id);
      cb.addEventListener("change", () => cb.checked ? state.selected.add(m.id) : state.selected.delete(m.id));
      const span = document.createElement("span");
      span.textContent = m.name;
      label.appendChild(cb);
      label.appendChild(span);
      elMethodChips.appendChild(label);
    }
  }

  function render_test_buttons() {
    elTestButtons.innerHTML = "";
    for (const t of TESTS) {
      const btn = document.createElement("button");
      btn.textContent = t.label;
      btn.addEventListener("click", () => {
        elInput.value = t.text;
        update_run_button_state();
        run_analysis();
      });
      elTestButtons.appendChild(btn);
    }
  }

  document.getElementById("runAll").addEventListener("click", () => {
    state.selected = new Set(METHODS.map(m => m.id));
    render_method_chips();
    if (has_text()) run_analysis();
  });

  document.getElementById("clearSel").addEventListener("click", () => {
    state.selected = new Set();
    render_method_chips();
    elResults.innerHTML = "";
    clear_error();
    elLastRun.textContent = now_local_string();
    elTokenInfo.textContent = "–";
    elInputType.textContent = "–";
    elApiUsed.textContent = "–";
  });

  document.getElementById("clearText").addEventListener("click", () => {
    elInput.value = "";
    update_run_button_state();
    elResults.innerHTML = "";
    clear_error();
    elLastRun.textContent = now_local_string();
    elTokenInfo.textContent = "–";
    elInputType.textContent = "–";
    elApiUsed.textContent = "–";
  });

  elRun.addEventListener("click", run_analysis);
  elInput.addEventListener("input", update_run_button_state);

  render_method_chips();
  render_test_buttons();
  update_run_button_state();
  update_api_status();
</script>
</body>
</html>
