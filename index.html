<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Markers & Watermark Artifact Scanner (Text + Code)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #101826;
      --panel2: #0f1622;
      --panel3: #0b121d;
      --text: #e7eefc;
      --muted: #9ab0d1;
      --line: rgba(255,255,255,0.10);
      --accent: #7aa2ff;
      --ok: #7df0c1;
      --warn: #ffd36a;
      --bad: #ff7a9a;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background:
        radial-gradient(1100px 700px at 20% 10%, rgba(122,162,255,0.14), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(125,240,193,0.08), transparent 60%),
        var(--bg);
      color: var(--text);
      font-family: var(--sans);
      line-height: 1.35;
    }
    .wrap { max-width: 1180px; margin: 28px auto; padding: 0 18px 60px; }
    header { display: flex; align-items: flex-start; gap: 16px; justify-content: space-between; margin-bottom: 14px; }
    h1 { margin: 0; font-size: 20px; letter-spacing: 0.2px; }
    .sub { margin-top: 6px; color: var(--muted); font-size: 13px; max-width: 860px; }

    /* OPAQUE PANELS to prevent gradient banding “streaks” */
    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .grid { display: grid; grid-template-columns: 1.15fr 0.85fr; gap: 14px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
    .pane { padding: 14px; }

    textarea {
      width: 100%;
      min-height: 330px;
      resize: vertical;
      background: var(--panel2);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      font-family: var(--mono);
      font-size: 13px;
      outline: none;
    }
    textarea:focus { border-color: rgba(122,162,255,0.55); box-shadow: 0 0 0 3px rgba(122,162,255,0.14); }

    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .row + .row { margin-top: 10px; }
    .label { font-size: 12px; color: var(--muted); margin-right: 8px; }

    .radio, .check {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: var(--panel2);
      user-select: none;
    }
    .radio input, .check input { accent-color: var(--accent); }
    .radio small, .check small { color: var(--muted); font-size: 12px; }

    .btnbar { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    button {
      background: rgba(122,162,255,0.18);
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.35);
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    button:hover { background: rgba(122,162,255,0.22); }
    button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      background: rgba(255,255,255,0.06);
      border-color: var(--line);
    }
    .ghost { background: rgba(255,255,255,0.06); border-color: var(--line); }
    .ghost:hover { background: rgba(255,255,255,0.08); }

    .small { font-size: 12px; color: var(--muted); }
    .secttitle { display: flex; align-items: center; justify-content: space-between; margin: 0 0 10px; font-size: 13px; color: var(--muted); }

    .chips { display: flex; flex-wrap: wrap; gap: 8px; }
    .chip {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--panel2);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
    }
    .chip input { accent-color: var(--accent); }
    .chip a { color: var(--muted); text-decoration: none; border-bottom: 1px dotted rgba(154,176,209,0.4); }
    .chip a:hover { color: var(--text); border-bottom-color: rgba(231,238,252,0.5); }

    .status {
      margin-top: 10px;
      padding: 10px;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .kvs { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 12px; }
    .kv { display: flex; justify-content: space-between; gap: 12px; }
    .kv b { color: var(--text); font-weight: 650; }

    .pill {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--line);
      background: var(--panel2);
    }
    .pill.proof { border-color: rgba(125,240,193,0.35); background: rgba(125,240,193,0.12); color: var(--ok); }
    .pill.strong { border-color: rgba(122,162,255,0.35); background: rgba(122,162,255,0.12); color: var(--accent); }
    .pill.medium { border-color: rgba(255,211,106,0.35); background: rgba(255,211,106,0.12); color: var(--warn); }
    .pill.hint { border-color: rgba(255,255,255,0.14); background: rgba(255,255,255,0.05); color: var(--muted); }

    .results { margin-top: 14px; }
    .group {
      margin-top: 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      background: var(--panel2);
    }
    .group > .ghead {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: var(--panel);
    }
    .ghead .left { display: flex; align-items: center; gap: 10px; }
    .ghead .title { font-size: 13px; color: var(--text); font-weight: 700; }
    .ghead .meta { font-size: 12px; color: var(--muted); }
    .items { padding: 10px 12px; background: var(--panel2); }

    .item {
      padding: 10px 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--panel3);
      margin-bottom: 10px;
    }
    .item:last-child { margin-bottom: 0; }
    .itemtop { display:flex; justify-content: space-between; gap: 10px; align-items:flex-start; }
    .ititle { font-size: 12px; font-weight: 700; color: var(--text); }
    .imeta { font-size: 12px; color: var(--muted); }
    .irow { margin-top: 6px; font-size: 12px; color: var(--muted); }

    code.inline {
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
    }

    .apirow { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .apirow input[type="text"]{
      background: var(--panel2);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      min-width: 280px;
      font-size: 12px;
      outline: none;
    }
    .apirow input[type="text"]:focus { border-color: rgba(122,162,255,0.55); box-shadow: 0 0 0 3px rgba(122,162,255,0.14); }
    .footnote { margin-top: 10px; color: var(--muted); font-size: 12px; }
    .muted { color: var(--muted); }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>AI Markers & Watermark Artifact Scanner</h1>
      <div class="sub">
        Detects <b>verifiable artifacts</b> in text/code: Unicode invisibles & controls, BiDi/Trojan Source, normalization drift,
        conservative mixed-script/confusables (code-only), whitespace channels, URL tracking tokens, and strictly validated payloads
        (percent/base64/deflate/gzip → text/JSON/magic bytes).
      </div>
      <div class="sub muted">
        Evidence levels: <span class="pill proof">PROOF</span> <span class="pill strong">STRONG</span> <span class="pill medium">MEDIUM</span> <span class="pill hint">HINT</span>
        — The tool can prove the presence of certain markers. It cannot prove “AI-generated” without a specific keyed watermark/provenance.
      </div>
    </div>
  </header>

  <div class="grid">
    <div class="card pane">
      <div class="secttitle">
        <div>Input</div>
        <div class="small" id="inputStats">0 chars</div>
      </div>
      <textarea id="input" placeholder="Paste text or code here (no file upload)."></textarea>

      <div class="row" style="margin-top:10px;">
        <span class="label">Input mode</span>
        <label class="radio"><input type="radio" name="mode" value="auto" checked> Auto</label>
        <label class="radio"><input type="radio" name="mode" value="text"> Text</label>
        <label class="radio"><input type="radio" name="mode" value="code"> Code</label>
      </div>

      <div class="row">
        <label class="check"><input type="checkbox" id="maskUrls" checked> Mask URLs for payload scans <small>(reduces false positives)</small></label>
        <label class="check"><input type="checkbox" id="strictBase64" checked> Strict Base64 mode <small>(decode+plausibility required)</small></label>
        <label class="check"><input type="checkbox" id="analyzeUrlParams" checked> Analyze URL params for tracking/payload</label>
      </div>

      <div class="row apirow">
        <label class="check"><input type="checkbox" id="useApi"> Use PHP API (optional)</label>
        <input type="text" id="apiEndpoint" value="./api/analyze.php" spellcheck="false" />
        <span class="small" id="apiStatus">API: off</span>
      </div>

      <div class="btnbar">
        <button id="run" disabled>Run analysis</button>
        <button id="clear" class="ghost" disabled>Clear text</button>
        <button id="copyJson" class="ghost" disabled>Copy JSON report</button>
        <button id="downloadJson" class="ghost" disabled>Download JSON report</button>
      </div>

      <div class="status" id="statusBox" aria-live="polite">
        <div class="kvs">
          <div class="kv"><span>SHA-256 (input)</span><b id="sha">—</b></div>
          <div class="kv"><span>Detected mode</span><b id="detMode">—</b></div>
          <div class="kv"><span>Total findings</span><b id="tot">0</b></div>
          <div class="kv"><span>Runtime</span><b id="rt">—</b></div>
        </div>
        <div class="footnote">
          Tip: For forensic notes, keep the report JSON together with the exact input and hash.
        </div>
      </div>
    </div>

    <div class="card pane">
      <div class="secttitle">
        <div>Checks (conservative)</div>
        <div class="small">Links explain each method</div>
      </div>

      <div class="chips" id="checks"></div>
      <div class="results" id="results"></div>
    </div>
  </div>
</div>

<script>
const METHODS = [
  { id: "unicode_specials", label: "Unicode invisibles & controls", level: "PROOF", score: 95,
    link: "https://www.unicode.org/reports/tr44/#General_Category_Values" },
  { id: "unicode_bidi", label: "BiDi / Trojan Source controls", level: "PROOF", score: 95,
    link: "https://trojansource.codes/" },
  { id: "unicode_normalization", label: "Normalization drift (NFKC/NFC)", level: "MEDIUM", score: 70,
    link: "https://www.unicode.org/reports/tr15/" },
  { id: "unicode_homoglyph", label: "Mixed-script/confusables (code-only, conservative)", level: "MEDIUM", score: 70,
    link: "https://www.unicode.org/reports/tr39/" },

  { id: "whitespace_channel", label: "Whitespace channels (trailing/mixed indent)", level: "MEDIUM", score: 70,
    link: "https://en.wikipedia.org/wiki/Text_steganography" },

  { id: "urls_tracking", label: "URL tracking tokens (utm/gclid/fbclid/srsltid…)", level: "PROOF", score: 90,
    link: "https://en.wikipedia.org/wiki/UTM_parameters" },

  { id: "payload_percent", label: "Percent-encoding payload runs", level: "STRONG", score: 85,
    link: "https://url.spec.whatwg.org/#percent-encoded-bytes" },
  { id: "payload_base64", label: "Base64 payloads (strict decode graph)", level: "STRONG", score: 85,
    link: "https://www.rfc-editor.org/rfc/rfc4648" },
  { id: "payload_hex_escapes", label: "Hex blobs & escape payloads (\\xNN / \\uNNNN)", level: "MEDIUM", score: 70,
    link: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" },
  { id: "payload_entropy", label: "High-entropy runs (heuristic)", level: "HINT", score: 40,
    link: "https://en.wikipedia.org/wiki/Entropy_(information_theory)" },

  { id: "acrostics", label: "Acrostics (light heuristic)", level: "HINT", score: 30,
    link: "https://en.wikipedia.org/wiki/Acrostic" },
  { id: "repetition", label: "Repetition/uniformity hints (token trigrams)", level: "HINT", score: 30,
    link: "https://en.wikipedia.org/wiki/Type%E2%80%93token_ratio" },
];

const DEFAULT_SELECTED = new Set([
  "unicode_specials","unicode_bidi","unicode_normalization","unicode_homoglyph",
  "whitespace_channel","urls_tracking","payload_base64","payload_percent","payload_hex_escapes"
]);

const $ = (id) => document.getElementById(id);
const inputEl = $("input");
const runBtn = $("run");
const clearBtn = $("clear");
const copyBtn = $("copyJson");
const dlBtn = $("downloadJson");
const checksEl = $("checks");
const resultsEl = $("results");
const apiStatusEl = $("apiStatus");

let latestReport = null;

function escape_html(s) {
  return String(s).replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

function now_iso() { return new Date().toISOString(); }

function get_mode_choice() {
  const r = document.querySelector('input[name="mode"]:checked');
  return r ? r.value : "auto";
}

function auto_detect_mode(text) {
  const hasFence = /```/.test(text);
  const codeSignals = (text.match(/[{}()[\];<>=$]/g) || []).length;
  const lines = text.split(/\r?\n/);
  const looksLikeCodeLine = lines.some(l => /^\s*(function|class|const|let|var|if|for|while|return|import|export|public|private|protected|final|readonly)\b/.test(l));
  if (hasFence || looksLikeCodeLine) return "code";
  if (codeSignals >= 40 && text.length >= 400) return "code";
  return "text";
}

function selected_methods() {
  const selected = [];
  document.querySelectorAll('.chip input[type="checkbox"]').forEach(cb => {
    if (cb.checked) selected.push(cb.dataset.method);
  });
  return selected;
}

function set_run_enabled() {
  const t = inputEl.value.trim();
  runBtn.disabled = t.length === 0;
  clearBtn.disabled = inputEl.value.length === 0;
}

function render_checks() {
  checksEl.innerHTML = "";
  for (const m of METHODS) {
    const checked = DEFAULT_SELECTED.has(m.id);
    const div = document.createElement("label");
    div.className = "chip";
    div.innerHTML = `
      <input type="checkbox" data-method="${escape_html(m.id)}" ${checked ? "checked" : ""}>
      <span>${escape_html(m.label)}</span>
      <a href="${escape_html(m.link)}" target="_blank" rel="noreferrer">ref</a>
    `;
    checksEl.appendChild(div);
  }
}

function method_meta(id) {
  return METHODS.find(m => m.id === id) || { id, label: id, level: "HINT", score: 20, link: "" };
}

function evidence_sort_key(level) {
  return ({ "PROOF": 0, "STRONG": 1, "MEDIUM": 2, "HINT": 3 })[level] ?? 9;
}

function cp_hex(cp) {
  return "U+" + cp.toString(16).toUpperCase().padStart(4, "0");
}

function bytes_to_hex(bytes, max = 32) {
  const n = Math.min(bytes.length, max);
  let out = "";
  for (let i = 0; i < n; i++) out += bytes[i].toString(16).padStart(2, "0");
  if (bytes.length > max) out += "…";
  return out;
}

function safe_excerpt(text, idx, len = 50) {
  const start = Math.max(0, idx - 18);
  const end = Math.min(text.length, idx + len);
  return text.slice(start, end);
}

function compute_token_stats(text) {
  const tokens = text.match(/[\p{L}\p{N}]+|[^\s]/gu) || [];
  const uniq = new Set(tokens);
  const ttr = uniq.size / Math.max(1, tokens.length);

  const freq = new Map();
  for (const t of tokens) freq.set(t, (freq.get(t) || 0) + 1);
  let H = 0;
  for (const c of freq.values()) {
    const p = c / tokens.length;
    H += -p * Math.log2(p);
  }

  let rep = 0;
  const seen = new Map();
  for (let i = 0; i + 2 < tokens.length; i++) {
    const tri = tokens[i] + "\u0001" + tokens[i+1] + "\u0001" + tokens[i+2];
    const v = (seen.get(tri) || 0) + 1;
    seen.set(tri, v);
  }
  for (const v of seen.values()) if (v >= 2) rep += (v - 1);

  return { tokens: tokens.length, unique: uniq.size, ttr: Number(ttr.toFixed(3)), entropy: Number(H.toFixed(3)), repeated_trigrams: rep };
}

function extract_urls(text) {
  const re = /\bhttps?:\/\/[^\s<>()"']+/gi;
  const out = [];
  let m;
  while ((m = re.exec(text)) !== null) out.push({ url: m[0], index: m.index });
  return out;
}

function clean_url_for_parsing(u) {
  return u.replace(/[)\].,;:!?]+$/g, "");
}

/* IMPORTANT: keep UTF-16 indexing (regex indices are UTF-16). */
function mask_urls(text, urls) {
  if (!urls.length) return text;
  const chars = text.split(""); // UTF-16 code units, matches regex indices
  for (const u of urls) {
    for (let i = u.index; i < u.index + u.url.length && i < chars.length; i++) chars[i] = " ";
  }
  return chars.join("");
}

function tracking_findings_for_url(urlStr) {
  const findings = [];
  const trackKeys = [
    "utm_source","utm_medium","utm_campaign","utm_term","utm_content",
    "gclid","dclid","gbraid","wbraid","fbclid","msclkid","srsltid","yclid","mc_cid","mc_eid"
  ];
  let u;
  try { u = new URL(clean_url_for_parsing(urlStr)); } catch { return findings; }
  for (const [k, v] of u.searchParams.entries()) {
    const key = k.toLowerCase();
    if (trackKeys.includes(key)) findings.push({ key, value: v, kind: "tracking_param" });
  }
  return findings;
}

function is_printable_text(s) {
  if (!s) return false;
  const bad = (s.match(/\uFFFD/g) || []).length;
  const ratio = 1 - (bad / s.length);
  return ratio >= 0.995;
}

function magic_bytes_kind(bytes) {
  if (bytes.length < 4) return null;
  if (bytes[0] === 0x1F && bytes[1] === 0x8B) return "gzip";
  if (bytes[0] === 0x78 && (bytes[1] === 0x01 || bytes[1] === 0x5E || bytes[1] === 0x9C || bytes[1] === 0xDA)) return "zlib";
  if (bytes[0] === 0x50 && bytes[1] === 0x4B && bytes[2] === 0x03 && bytes[3] === 0x04) return "zip";
  if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) return "pdf";
  return null;
}

function utf8_preview(bytes, maxChars = 220) {
  try {
    const td = new TextDecoder("utf-8", { fatal: false });
    const s = td.decode(bytes);
    const preview = s.slice(0, maxChars);
    const bad = (preview.match(/\uFFFD/g) || []).length;
    const ratio = 1 - (bad / Math.max(1, preview.length));
    return { ok: ratio >= 0.98, ratio: Number(ratio.toFixed(3)), preview };
  } catch {
    return { ok: false, ratio: 0, preview: "" };
  }
}

function normalize_base64(s, urlSafe) {
  let t = s;
  if (urlSafe) t = t.replace(/-/g, "+").replace(/_/g, "/");
  const mod = t.length % 4;
  if (mod === 1) return null;
  if (mod === 2) t += "==";
  if (mod === 3) t += "=";
  return t;
}

function atob_bytes(b64) {
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i) & 0xFF;
  return bytes;
}

async function decompress_bytes(bytes, fmt) {
  if (typeof DecompressionStream === "undefined") return null;
  try {
    const ds = new DecompressionStream(fmt);
    const blob = new Blob([bytes]);
    const stream = blob.stream().pipeThrough(ds);
    const ab = await new Response(stream).arrayBuffer();
    return new Uint8Array(ab);
  } catch {
    return null;
  }
}

/*
  Base64 candidates (conservative):
  - allow shorter payloads when STRICT decode validates (e.g. SGVsbG8sIFVsaSE=)
  - avoid false positives: require at least one of [digit, '=', '+', '/'] for base64
  - avoid double-reporting: treat Base64URL only if '-' or '_' is present
*/
function base64_candidates(text) {
  const out = [];
  let m;

  const reB64 = /(^|[^A-Za-z0-9+\/=])([A-Za-z0-9+\/]{12,}(?:={0,2}))(?![A-Za-z0-9+\/=])/g;
  while ((m = reB64.exec(text)) !== null) {
    const prefix = m[1] || "";
    const cand = m[2];
    if (cand.length < 16) continue;
    if (!/[0-9=+\/]/.test(cand)) continue; // filters normal long words
    const idx = m.index + prefix.length;
    out.push({ kind: "base64", cand, index: idx });
  }

  const reB64Url = /(^|[^A-Za-z0-9_=-])([A-Za-z0-9_-]{12,}(?:={0,2}))(?![A-Za-z0-9_=-])/g;
  while ((m = reB64Url.exec(text)) !== null) {
    const prefix = m[1] || "";
    const cand = m[2];
    if (cand.length < 16) continue;
    if (!/[-_]/.test(cand)) continue;      // avoids duplicates with base64 subset
    if (!/[0-9=_-]/.test(cand)) continue;  // filters normal long words
    const idx = m.index + prefix.length;
    out.push({ kind: "base64url", cand, index: idx });
  }

  return out;
}

function percent_runs(text, minCount = 12) {
  const hits = [];
  const re = /%[0-9A-Fa-f]{2}/g;
  let m;
  let last = -10, start = -1, count = 0;
  while ((m = re.exec(text)) !== null) {
    if (start === -1) { start = m.index; count = 1; last = m.index; continue; }
    if (m.index - last <= 4) { count++; last = m.index; continue; }
    if (count >= minCount) hits.push({ index: start, count });
    start = m.index; count = 1; last = m.index;
  }
  if (count >= minCount) hits.push({ index: start, count });
  return hits;
}

function shannon_entropy(s) {
  const freq = new Map();
  for (const ch of s) freq.set(ch, (freq.get(ch) || 0) + 1);
  const n = s.length || 1;
  let H = 0;
  for (const c of freq.values()) {
    const p = c / n;
    H += -p * Math.log2(p);
  }
  return H;
}

function entropy_runs(text) {
  const re = /[A-Za-z0-9+/=_-]{80,}/g;
  const out = [];
  let m;
  while ((m = re.exec(text)) !== null) {
    const s = m[0];
    const H = shannon_entropy(s);
    if (H >= 4.4) out.push({ index: m.index, length: s.length, entropy: Number(H.toFixed(3)) });
  }
  return out;
}

function unicode_findings_client(text) {
  const findings = [];

  const bidi = new Map([
    [0x202A,"LRE"],[0x202B,"RLE"],[0x202C,"PDF"],[0x202D,"LRO"],[0x202E,"RLO"],
    [0x2066,"LRI"],[0x2067,"RLI"],[0x2068,"FSI"],[0x2069,"PDI"],
    [0x200E,"LRM"],[0x200F,"RLM"],
  ]);
  const invis = new Map([
    [0x200B,"ZWSP"],[0x200C,"ZWNJ"],[0x200D,"ZWJ"],[0x2060,"WORD JOINER"],
    [0xFEFF,"BOM"],[0x00A0,"NBSP"],[0x202F,"NNBSP"],[0x2007,"FIGURE SPACE"],
    [0x2009,"THIN SPACE"],[0x200A,"HAIR SPACE"],[0x3000,"IDEOGRAPHIC SPACE"],
    [0x034F,"COMBINING GRAPHEME JOINER"],
  ]);

  let i = 0;
  for (const ch of text) {
    const cp = ch.codePointAt(0);
    const isVs = (cp >= 0xFE00 && cp <= 0xFE0F) || (cp >= 0xE0100 && cp <= 0xE01EF);
    const isTag = (cp >= 0xE0000 && cp <= 0xE007F);
    const isCtl = (cp < 32 && cp !== 9 && cp !== 10 && cp !== 13) || cp === 0x7F;

    if (bidi.has(cp)) {
      findings.push({ method: "unicode_bidi", level: "PROOF", score: 95,
        message: `BiDi control ${bidi.get(cp)} (${cp_hex(cp)})`, index: i, excerpt: safe_excerpt(text, i) });
    } else if (invis.has(cp)) {
      findings.push({ method: "unicode_specials", level: "PROOF", score: 95,
        message: `Invisible/special ${invis.get(cp)} (${cp_hex(cp)})`, index: i, excerpt: safe_excerpt(text, i) });
    } else if (isVs) {
      findings.push({ method: "unicode_specials", level: "PROOF", score: 92,
        message: `Variation Selector (${cp_hex(cp)})`, index: i, excerpt: safe_excerpt(text, i) });
    } else if (isTag) {
      findings.push({ method: "unicode_specials", level: "PROOF", score: 92,
        message: `Unicode Tag character (${cp_hex(cp)})`, index: i, excerpt: safe_excerpt(text, i) });
    } else if (isCtl) {
      findings.push({ method: "unicode_specials", level: "PROOF", score: 95,
        message: `Control character (${cp_hex(cp)})`, index: i, excerpt: safe_excerpt(text, i) });
    }

    i += ch.length; // keep UTF-16 indexing
  }

  try {
    const markRe = /\p{M}+/gu;
    let m;
    while ((m = markRe.exec(text)) !== null) {
      if (m[0].length >= 3) {
        findings.push({ method: "unicode_specials", level: "HINT", score: 25,
          message: `Combining marks run length ${m[0].length}`, index: m.index, excerpt: safe_excerpt(text, m.index) });
      }
    }
  } catch {}

  return findings;
}

function bidi_pairing_issues_client(text) {
  const issues = [];
  const openEmbed = new Set([0x202A,0x202B,0x202D,0x202E]);
  const openIsol  = new Set([0x2066,0x2067,0x2068]);
  const closePdf = 0x202C;
  const closePdi = 0x2069;

  const lines = text.split(/\r?\n/);
  for (let li = 0; li < lines.length; li++) {
    const line = lines[li];
    const stack = [];
    for (const ch of line) {
      const cp = ch.codePointAt(0);
      if (openEmbed.has(cp)) stack.push(closePdf);
      else if (openIsol.has(cp)) stack.push(closePdi);
      else if (cp === closePdf || cp === closePdi) {
        if (!stack.length) issues.push({ line: li+1, issue: "unmatched_close", cp });
        else {
          const expected = stack.pop();
          if (expected !== cp) issues.push({ line: li+1, issue: "mismatched_close", cp, expected });
        }
      }
    }
    while (stack.length) {
      const expected = stack.pop();
      issues.push({ line: li+1, issue: "unclosed_open", expected });
    }
  }
  return issues;
}

function normalization_findings(text) {
  const out = [];
  try {
    const nfc = text.normalize("NFC");
    const nfkc = text.normalize("NFKC");
    if (nfc !== text) out.push({ method: "unicode_normalization", level: "MEDIUM", score: 60,
      message: "Text differs from NFC normalization (canonical drift).", index: 0, excerpt: "" });
    if (nfkc !== text) out.push({ method: "unicode_normalization", level: "MEDIUM", score: 70,
      message: "Text differs from NFKC normalization (compatibility drift).", index: 0, excerpt: "" });
  } catch {}
  return out;
}

function whitespace_findings(text) {
  const out = [];
  const lines = text.split(/\r?\n/);
  let trailingCount = 0;
  let trailingTabs = 0;
  let mixedIndentLines = 0;
  const examples = [];

  for (let i = 0; i < lines.length; i++) {
    const l = lines[i];
    if (/[ \t]+$/.test(l)) {
      trailingCount++;
      if (/\t+$/.test(l)) trailingTabs++;
      if (examples.length < 5) examples.push({ line: i+1, kind: "trailing_whitespace" });
    }
    const indent = l.match(/^\s+/)?.[0] || "";
    if (indent.includes("\t") && indent.includes(" ")) {
      mixedIndentLines++;
      if (examples.length < 5) examples.push({ line: i+1, kind: "mixed_indent" });
    }
  }

  if (trailingTabs > 0 || trailingCount >= 3) {
    out.push({ method: "whitespace_channel", level: "MEDIUM", score: 70,
      message: `Trailing whitespace in ${trailingCount} line(s)${trailingTabs ? ` (includes ${trailingTabs} trailing tab line(s))` : ""}.`,
      index: 0, excerpt: JSON.stringify(examples) });
  }

  if (mixedIndentLines >= 2) {
    out.push({ method: "whitespace_channel", level: "MEDIUM", score: 70,
      message: `Mixed indentation (tabs+spaces) detected in ${mixedIndentLines} line(s).`, index: 0, excerpt: "" });
  }

  return out;
}

function is_latin_only_with_diacritics(token) {
  try { return /^[\p{Script=Latin}\p{N}_$]+$/u.test(token); }
  catch { return /^[\w$À-ÿ]+$/.test(token); }
}

function contains_proof_unicode(token) {
  return /[\u200B\u200C\u200D\u2060\uFEFF\u034F\u202A-\u202E\u2066-\u2069\u200E\u200F]/u.test(token);
}

function scripts_in_token(token) {
  const scripts = new Set();
  try {
    if (/\p{Script=Latin}/u.test(token)) scripts.add("Latin");
    if (/\p{Script=Cyrillic}/u.test(token)) scripts.add("Cyrillic");
    if (/\p{Script=Greek}/u.test(token)) scripts.add("Greek");
    if (/\p{Script=Arabic}/u.test(token)) scripts.add("Arabic");
    if (/\p{Script=Hebrew}/u.test(token)) scripts.add("Hebrew");
    if (/\p{Script=Han}/u.test(token)) scripts.add("Han");
    if (/\p{Script=Hangul}/u.test(token)) scripts.add("Hangul");
    if (/\p{Script=Devanagari}/u.test(token)) scripts.add("Devanagari");
  } catch {}
  return scripts;
}

function code_identifier_findings(text, mode) {
  const out = [];
  if (mode !== "code") return out;

  const blocks = [];
  const fenceRe = /```[\s\S]*?```/g;
  const fenced = text.match(fenceRe);
  if (fenced && fenced.length) {
    for (const b of fenced) blocks.push(b.replace(/^```[^\n]*\n?/, "").replace(/```$/, ""));
  } else {
    blocks.push(text);
  }

  const identRe = (() => {
    try { return /(?<![\p{L}\p{N}_$])([\p{L}_$][\p{L}\p{N}_$]{1,80})/gu; }
    catch { return /(^|[^A-Za-z0-9_$])([A-Za-z_$][A-Za-z0-9_$]{1,80})/g; }
  })();

  for (const block of blocks) {
    let m;
    while ((m = identRe.exec(block)) !== null) {
      const token = m[1] || m[2];
      if (!token) continue;

      if (is_latin_only_with_diacritics(token) && !contains_proof_unicode(token)) continue;

      if (contains_proof_unicode(token)) {
        out.push({ method: "unicode_homoglyph", level: "PROOF", score: 92,
          message: `Identifier contains invisible/BiDi control: "${token}"`, index: m.index, excerpt: token });
        continue;
      }

      const scripts = scripts_in_token(token);
      if (scripts.size >= 2) {
        out.push({ method: "unicode_homoglyph", level: "MEDIUM", score: 75,
          message: `Mixed scripts in identifier "${token}" (${Array.from(scripts).join(", ")})`, index: m.index, excerpt: token });
      }
    }
  }
  return out;
}

async function strict_base64_findings(text, strictBase64) {
  const out = [];
  const candidates = base64_candidates(text);

  for (const c of candidates) {
    if (!strictBase64) {
      out.push({ method: "payload_base64", level: "HINT", score: 25,
        message: `Base64-like run (${c.kind}) length ${c.cand.length}`, index: c.index, excerpt: safe_excerpt(text, c.index) });
      continue;
    }

    const norm = normalize_base64(c.cand, c.kind === "base64url");
    if (!norm) continue;

    let bytes;
    try { bytes = atob_bytes(norm); } catch { continue; }

    const magic = magic_bytes_kind(bytes);
    const utf8 = utf8_preview(bytes);

    if (utf8.ok) {
      let isJson = false;
      try { JSON.parse(utf8.preview); isJson = true; } catch {}
      out.push({ method: "payload_base64", level: "STRONG", score: isJson ? 92 : 85,
        message: `Decoded ${c.kind}: UTF-8 printable (ratio ${utf8.ratio})${isJson ? ", JSON-like" : ""}`,
        index: c.index, excerpt: utf8.preview });
      continue;
    }

    if (magic === "gzip" || magic === "zlib") {
      const fmt = (magic === "gzip") ? "gzip" : "deflate";
      const dec = await decompress_bytes(bytes, fmt);
      if (dec) {
        const utf2 = utf8_preview(dec);
        if (utf2.ok) {
          let isJson = false;
          try { JSON.parse(utf2.preview); isJson = true; } catch {}
          out.push({ method: "payload_base64", level: "STRONG", score: 94,
            message: `Decoded ${c.kind} → ${fmt}: UTF-8 printable (ratio ${utf2.ratio})${isJson ? ", JSON-like" : ""}`,
            index: c.index, excerpt: utf2.preview });
        } else {
          out.push({ method: "payload_base64", level: "MEDIUM", score: 70,
            message: `Decoded ${c.kind}: ${magic} bytes (not readable UTF-8)`,
            index: c.index, excerpt: `magic=${magic}, bytes[0..]=${bytes_to_hex(bytes, 24)}` });
        }
      } else {
        out.push({ method: "payload_base64", level: "MEDIUM", score: 70,
          message: `Decoded ${c.kind}: ${magic} bytes (browser cannot decompress)`,
          index: c.index, excerpt: `magic=${magic}, bytes[0..]=${bytes_to_hex(bytes, 24)}` });
      }
      continue;
    }

    if (magic) {
      out.push({ method: "payload_base64", level: "MEDIUM", score: 70,
        message: `Decoded ${c.kind}: magic bytes detected (${magic})`,
        index: c.index, excerpt: `magic=${magic}, bytes[0..]=${bytes_to_hex(bytes, 24)}` });
    }
  }

  return out;
}

function percent_payload_findings(text, strict) {
  const out = [];
  const hits = percent_runs(text, 12);
  for (const h of hits) {
    const window = text.slice(h.index, Math.min(text.length, h.index + 400));
    let decoded = null;
    try { decoded = decodeURIComponent(window.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")); } catch {}
    if (decoded && decoded.length >= 40 && is_printable_text(decoded)) {
      out.push({ method: "payload_percent", level: "STRONG", score: 85,
        message: `Percent-encoded run decoded to readable text (${h.count} sequences)`,
        index: h.index, excerpt: decoded.slice(0, 220) });
    } else if (!strict) {
      out.push({ method: "payload_percent", level: "HINT", score: 25,
        message: `Percent-encoded run (${h.count} sequences)`,
        index: h.index, excerpt: safe_excerpt(text, h.index) });
    }
  }
  return out;
}

function hex_escape_findings(text) {
  const out = [];
  const hexRe = /(?:0x)?[0-9A-Fa-f]{64,}/g;
  let m;
  while ((m = hexRe.exec(text)) !== null) {
    if (!/[A-Fa-f]/.test(m[0])) continue;
    out.push({ method: "payload_hex_escapes", level: "MEDIUM", score: 65,
      message: `Long hex-like blob length ${m[0].length}`, index: m.index, excerpt: m[0].slice(0, 80) + (m[0].length>80?"…":"") });
  }

  const escRe = /(\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\u\{[0-9A-Fa-f]{1,6}\})/g;
  const hits = [];
  while ((m = escRe.exec(text)) !== null) hits.push(m.index);
  if (hits.length >= 12) {
    out.push({ method: "payload_hex_escapes", level: "MEDIUM", score: 65,
      message: `High density of escape sequences (${hits.length})`, index: hits[0], excerpt: safe_excerpt(text, hits[0]) });
  }
  return out;
}

function entropy_findings(text) {
  const out = [];
  for (const h of entropy_runs(text)) {
    out.push({ method: "payload_entropy", level: "HINT", score: 35,
      message: `High-entropy run (H=${h.entropy}, len=${h.length})`, index: h.index, excerpt: safe_excerpt(text, h.index) });
  }
  return out;
}

function acrostic_findings(text) {
  const out = [];
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const firstLetters = lines.map(l => l[0]).join("").slice(0, 120);
  if (firstLetters.length >= 18) {
    out.push({ method: "acrostics", level: "HINT", score: 25,
      message: `Line acrostic sample: "${firstLetters}"`, index: 0, excerpt: "" });
  }
  const sentences = text.split(/[.!?]\s+/).map(s => s.trim()).filter(s => s.length >= 10);
  const sLetters = sentences.map(s => s[0]).join("").slice(0, 120);
  if (sLetters.length >= 18) {
    out.push({ method: "acrostics", level: "HINT", score: 25,
      message: `Sentence acrostic sample: "${sLetters}"`, index: 0, excerpt: "" });
  }
  return out;
}

function repetition_findings(text) {
  const stats = compute_token_stats(text);
  const out = [];
  if (stats.repeated_trigrams >= 6) {
    out.push({ method: "repetition", level: "HINT", score: 30,
      message: `Repeated trigrams detected: ${stats.repeated_trigrams} (template/copy-paste hint)`,
      index: 0, excerpt: JSON.stringify(stats) });
  }
  return { out, stats };
}

async function sha256_hex(text) {
  const enc = new TextEncoder();
  const data = enc.encode(text);
  const hash = await crypto.subtle.digest("SHA-256", data);
  const bytes = new Uint8Array(hash);
  let hex = "";
  for (const b of bytes) hex += b.toString(16).padStart(2, "0");
  return hex;
}

function render_report(report) {
  resultsEl.innerHTML = "";

  const groups = [
    { key: "PROOF", title: "PROOF (verifiable artifacts)", cls: "proof" },
    { key: "STRONG", title: "STRONG (validated decode / clear signal)", cls: "strong" },
    { key: "MEDIUM", title: "MEDIUM (conservative indicators)", cls: "medium" },
    { key: "HINT", title: "HINT (heuristics, not proof)", cls: "hint" },
  ];

  for (const g of groups) {
    const items = report.findings.filter(f => f.level === g.key);
    const box = document.createElement("div");
    box.className = "group";
    box.innerHTML = `
      <div class="ghead">
        <div class="left">
          <span class="pill ${g.cls}">${g.key}</span>
          <span class="title">${escape_html(g.title)}</span>
        </div>
        <div class="meta">${items.length} finding(s)</div>
      </div>
      <div class="items"></div>
    `;
    const itemsEl = box.querySelector(".items");

    if (!items.length) {
      const empty = document.createElement("div");
      empty.className = "item";
      empty.innerHTML = `<div class="imeta">No findings at this evidence level.</div>`;
      itemsEl.appendChild(empty);
    } else {
      for (const f of items.slice(0, 120)) {
        const m = method_meta(f.method);
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = `
          <div class="itemtop">
            <div>
              <div class="ititle">${escape_html(m.label)}</div>
              <div class="imeta">score ${escape_html(f.score)} · method <code class="inline">${escape_html(f.method)}</code> · ${f.source ? escape_html(f.source) : "client"}</div>
            </div>
            <div class="imeta">${typeof f.index === "number" ? `idx ${f.index}` : ""}${f.line ? ` · line ${f.line}` : ""}</div>
          </div>
          <div class="irow">${escape_html(f.message || "")}</div>
          ${f.excerpt ? `<div class="irow"><code class="inline">${escape_html(f.excerpt)}</code></div>` : ""}
        `;
        itemsEl.appendChild(div);
      }
    }

    resultsEl.appendChild(box);
  }
}

function update_api_status(text) {
  const useApi = $("useApi").checked;
  apiStatusEl.textContent = useApi ? text : "API: off";
}

async function call_api(text, selected, settings) {
  const endpoint = $("apiEndpoint").value.trim() || "./api/analyze.php";
  const payload = { text, selected, settings };
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), 3500);

  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal: ctrl.signal,
    });
    clearTimeout(t);
    if (!res.ok) return { ok: false, error: `HTTP ${res.status}` };
    const data = await res.json();
    return data;
  } catch (e) {
    clearTimeout(t);
    return { ok: false, error: (e && e.name === "AbortError") ? "timeout" : "fetch_failed" };
  }
}

function merge_api_findings(report, apiData) {
  if (!apiData || !apiData.ok) return;

  report.meta.api = apiData.meta || {};
  report.meta.urls_from_api = apiData.urls || [];

  const add = (f) => report.findings.push(f);

  if (apiData.server && apiData.server.unicode && Array.isArray(apiData.server.unicode)) {
    for (const u of apiData.server.unicode) {
      add({
        method: (u.kind === "bidi") ? "unicode_bidi" : "unicode_specials",
        level: u.evidence || "PROOF",
        score: u.score || 90,
        message: `${u.name || "Unicode"} (${u.hex || ""})`,
        index: (typeof u.char_index === "number") ? u.char_index : null,
        excerpt: "",
        source: "server",
      });
    }
  }

  if (apiData.server && apiData.server.bidi_pairing && Array.isArray(apiData.server.bidi_pairing)) {
    for (const b of apiData.server.bidi_pairing) {
      add({
        method: "unicode_bidi",
        level: "PROOF",
        score: 90,
        message: `BiDi pairing issue: ${b.issue} (${b.hex || ""} ${b.name || ""})`,
        line: b.line || null,
        index: null,
        excerpt: "",
        source: "server",
      });
    }
  }

  if (apiData.server && apiData.server.spoofchecker && apiData.server.spoofchecker.available) {
    for (const it of (apiData.server.spoofchecker.items || [])) {
      add({
        method: "unicode_homoglyph",
        level: it.evidence || "MEDIUM",
        score: it.score || 70,
        message: `ICU Spoofchecker suspicious token: "${it.token}"`,
        index: null,
        excerpt: it.skeleton ? `skeleton: ${it.skeleton}` : "",
        source: "server",
      });
    }
  }

  if (apiData.server && apiData.server.base64 && Array.isArray(apiData.server.base64)) {
    for (const h of apiData.server.base64) {
      add({
        method: "payload_base64",
        level: h.evidence || "STRONG",
        score: h.score || 85,
        message: `Server decode: ${h.kind} (magic=${h.magic ? "yes" : "no"}, utf8_ratio=${h.utf8_ratio ?? "n/a"})`,
        index: h.index || null,
        excerpt: h.preview || "",
        source: "server",
      });
    }
  }

  const seen = new Set();
  report.findings = report.findings.filter(f => {
    const key = `${f.method}|${f.level}|${f.index ?? ""}|${f.line ?? ""}|${f.message}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function finalize_report(report) {
  report.findings.sort((a,b) => {
    const ka = evidence_sort_key(a.level), kb = evidence_sort_key(b.level);
    if (ka !== kb) return ka - kb;
    const ia = (typeof a.index === "number") ? a.index : 1e12;
    const ib = (typeof b.index === "number") ? b.index : 1e12;
    return ia - ib;
  });
  return report;
}

async function run_analysis() {
  const t0 = performance.now();

  const textRaw = inputEl.value;
  const text = textRaw.trimEnd();
  const selected = selected_methods();

  const settings = {
    maskUrls: $("maskUrls").checked,
    strictBase64: $("strictBase64").checked,
    analyzeUrlParams: $("analyzeUrlParams").checked,
    useApi: $("useApi").checked,
    apiEndpoint: $("apiEndpoint").value.trim() || "./api/analyze.php",
    modeChoice: get_mode_choice(),
  };

  const mode = (settings.modeChoice === "auto") ? auto_detect_mode(text) : settings.modeChoice;

  const urls = extract_urls(text);
  const scanText = settings.maskUrls ? mask_urls(text, urls) : text;

  const report = {
    meta: {
      timestamp: now_iso(),
      userAgent: navigator.userAgent,
      detectedMode: mode,
      urlCount: urls.length,
    },
    settings,
    selected,
    stats: {},
    urls: [],
    findings: [],
  };

  if (selected.includes("urls_tracking") || selected.includes("payload_percent") || selected.includes("payload_base64")) {
    for (const u of urls) {
      const track = tracking_findings_for_url(u.url);
      if (settings.analyzeUrlParams && track.length && selected.includes("urls_tracking")) {
        for (const tr of track) {
          report.findings.push({
            method: "urls_tracking",
            level: "PROOF",
            score: 90,
            message: `Tracking-like URL parameter "${tr.key}"`,
            index: u.index,
            excerpt: u.url.length > 220 ? u.url.slice(0,220) + "…" : u.url,
            source: "client",
          });
        }
      }
      report.urls.push({ ...u, tracking: track });
    }
  }

  if (selected.includes("unicode_specials") || selected.includes("unicode_bidi")) {
    report.findings.push(...unicode_findings_client(text));
  }

  if (selected.includes("unicode_bidi")) {
    const issues = bidi_pairing_issues_client(text);
    for (const it of issues) {
      report.findings.push({
        method: "unicode_bidi",
        level: "PROOF",
        score: 90,
        message: (it.issue === "unclosed_open")
          ? `BiDi pairing issue: unclosed open (expected ${cp_hex(it.expected)})`
          : (it.issue === "mismatched_close")
            ? `BiDi pairing issue: mismatched close (${cp_hex(it.cp)} expected ${cp_hex(it.expected)})`
            : `BiDi pairing issue: unmatched close (${cp_hex(it.cp)})`,
        line: it.line,
        index: null,
        excerpt: "",
        source: "client",
      });
    }
  }

  if (selected.includes("unicode_normalization")) report.findings.push(...normalization_findings(text));
  if (selected.includes("whitespace_channel")) report.findings.push(...whitespace_findings(text));
  if (selected.includes("unicode_homoglyph")) report.findings.push(...code_identifier_findings(text, mode));

  if (selected.includes("payload_percent")) report.findings.push(...percent_payload_findings(scanText, true));
  if (selected.includes("payload_hex_escapes")) report.findings.push(...hex_escape_findings(scanText));
  if (selected.includes("payload_entropy")) report.findings.push(...entropy_findings(scanText));
  if (selected.includes("payload_base64")) report.findings.push(...await strict_base64_findings(scanText, settings.strictBase64));

  if (selected.includes("acrostics")) report.findings.push(...acrostic_findings(text));

  let repStats = null;
  if (selected.includes("repetition")) {
    const r = repetition_findings(text);
    report.findings.push(...r.out);
    repStats = r.stats;
  }

  const stats = compute_token_stats(text);
  report.stats = {
    chars: text.length,
    lines: text.split(/\r?\n/).length,
    ...stats,
    repetitionStats: repStats || null,
  };

  if (settings.useApi) {
    update_api_status("API: calling…");
    const apiData = await call_api(text, selected, settings);
    if (apiData.ok) {
      update_api_status(`API: ok (intl=${apiData.meta?.intl_available ? "yes" : "no"}, spoof=${apiData.meta?.spoofchecker_available ? "yes" : "no"})`);
      merge_api_findings(report, apiData);
    } else {
      update_api_status(`API: unavailable (${apiData.error || "error"})`);
      report.meta.api = { ok: false, error: apiData.error || "error" };
    }
  } else {
    update_api_status("API: off");
  }

  finalize_report(report);

  $("sha").textContent = "…";
  const hash = await sha256_hex(text);
  report.meta.sha256 = hash;

  const t1 = performance.now();
  $("sha").textContent = hash;
  $("detMode").textContent = mode;
  $("tot").textContent = String(report.findings.length);
  $("rt").textContent = (t1 - t0).toFixed(1) + " ms";

  render_report(report);

  latestReport = report;
  copyBtn.disabled = false;
  dlBtn.disabled = false;
}

function set_input_stats() {
  const v = inputEl.value;
  $("inputStats").textContent = `${v.length} chars`;
}

function download_json(obj) {
  const json = JSON.stringify(obj, null, 2);
  const blob = new Blob([json], { type: "application/json;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `artifact-report-${(new Date()).toISOString().replace(/[:.]/g,"-")}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function copy_json(obj) {
  const json = JSON.stringify(obj, null, 2);
  return navigator.clipboard.writeText(json);
}

function reset_ui() {
  resultsEl.innerHTML = "";
  $("sha").textContent = "—";
  $("detMode").textContent = "—";
  $("tot").textContent = "0";
  $("rt").textContent = "—";
  latestReport = null;
  copyBtn.disabled = true;
  dlBtn.disabled = true;
  update_api_status($("useApi").checked ? "API: enabled (will call on Run)" : "API: off");
}

// Wire up UI
render_checks();
set_run_enabled();
set_input_stats();
reset_ui();

inputEl.addEventListener("input", () => {
  set_run_enabled();
  set_input_stats();
});

$("useApi").addEventListener("change", () => {
  update_api_status($("useApi").checked ? "API: enabled (will call on Run)" : "API: off");
});

runBtn.addEventListener("click", async () => {
  runBtn.disabled = true;
  try { await run_analysis(); }
  finally { set_run_enabled(); }
});

clearBtn.addEventListener("click", () => {
  inputEl.value = "";
  set_input_stats();
  set_run_enabled();
  reset_ui();
});

copyBtn.addEventListener("click", async () => {
  if (!latestReport) return;
  try {
    await copy_json(latestReport);
    copyBtn.textContent = "Copied!";
    setTimeout(() => copyBtn.textContent = "Copy JSON report", 900);
  } catch {
    copyBtn.textContent = "Copy failed";
    setTimeout(() => copyBtn.textContent = "Copy JSON report", 900);
  }
});

dlBtn.addEventListener("click", () => {
  if (!latestReport) return;
  download_json(latestReport);
});
</script>
</body>
</html>
